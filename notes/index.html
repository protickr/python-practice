<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Notes</title>
    <style type="text/css">
        * {
            box-sizing: border-box;
            margin: 0;
        }

        main {
            width: 900px;
            margin: 0 auto;
        }

    </style>
</head>
<body>
    <main>
        <pre>
        <h2>Fundamentals: installation, execution, variables, data types</h2>
        <p>
            Installation and basic script execution
            1. install python and set environment variables so that python is recognized as a command 

            2. check version in terminal by, 
                python --version 

            3. create a file with extension .py e.g., main.py
            4. execute a python script from terminal by 
                python path_to_python_script.py

            * take input from console 
                x =  input('enter a number')
                input method always returns string 

            * print() 
                1. print() can take multiple arguments seperated by comma 
                2. print() takes a keyword argument 'sep' to add seperation between strings 
                3. print("%2f", 10.5)

                
            Variables
            variable is an identifer to a location in the memory, it is a container that hold a value 
            e.g., here 'message' is a variable which stores the value 'hello world' 
                message = 'hello world'
                print(message)

            * Variable naming convention 
                1. should be lowercase, in case of multiple words in a variable, all words should be 
                    linked by underscores e.g., multiple_word_variable = 10
                2. should not start with a number or special symbool or hyphen
                3. ALL_CAPS for constants 
                4. PascalCase for class names 


            Data Types
                1. integer, number with no decimal point, whole number
                2. float, number with a decimal point, decimal number
                3. string, string object. 
                4. booleans, True, False
                5. Set 
                6. Dictionary
                7. complex number
                8. null value, None

                python is dynamically typed meaning, the type of value determines the type of a varaible


                * integer &lt;class 'int'&gt;
                    num = 10
                    
                * float &lt;class 'float'&gt;
                    num = 10.6

                * complex number 
                    In python, you can put 'j' or 'J' after a number to make it imaginary, so you can write complex 
                    literals easily:
                        1. z = 2 + 3j
                        2. z =  complex(2,3)
                         z.real == 2.0
                         z.imag == 3.0
                        
                * type casting / converison 
                    num_1 = '10'
                    num_2 = '10.5'
                    
                    * string to int, float
                        print(int(num_1), float(num_2))     # 10 10.5
        </p>

        <h2>Strings</h2>
        <p>
            string is an sequence of characters which is stored as String object in python 

            string can be created by using double or single quotes, 
                message = 'this is a string'
                message = "This is a string"

            multi line string: 
                multi line string can be created by using 3 double or single quotes, 
                retians white space and formatting as created
                
                    message = '''hello 
                    world!'''
                    print(message)
                    
                    output: 
                    hello 
                    world!

            escape character 
                \ (back slash) is used to escape the character that follows it in a string so that it does not 
                have a special meaning 
                e.g., 
                    'a string with escape character it\'s'

            string methods: 
                message = "Hello world!"

                * lower case
                    message.lower()         # hello world!

                * upper case 
                    message.upper()         # HELLO WORLD!

                * count number of occurance of a substring in a string 
                    message.count("world")   # 1
                    message.count("o")       # 2
                    message.count("t")       # 0
                

                * find starting index of a substring in a string 
                    only returns the first match 
                    message.find("world")    # 6
                    message.find('universe') # -1, if no match found

                * replace parts of a string with another string 
                    does not mutate the original string; returns a new string 
                    message.replace("world", "universe")     # Hello universe!

                * strip() characters at start and end of a string 
                    'this is a string'.strip()
                    if no argument is passed it strips empty whitespace and \n from start and end of a string
                    
                * string.islower() # True or False
                * string.isupper() # True or False

                * string concatanation 
                    greetings = "Hey"
                    name = "John"

                    * with (+) operator
                        message = "Hello " + "world!"
                        print(message)      # Hello world!

                    * with str.format() method / formatted string
                        message = '{}, {}. Welcome! '.format(greetings, name)
                        print(message)      # Hey, John. Welcome! 

                    * with f-string (template literals in JS)
                        message = f'{greetings}, {name}. Welcome!'
                        print(message)      # Hey, John. Welcome!


            * String formatting 
                1. string concatenation using + operator 
                2. string.format() method

                    name = 'Protick'
                    age = 28 

                    * placeholder wihtout index 
                        txt = 'I am {} my age is {}'.format(name, age)
                        print(txt)      # I am Protick my age is 28

                    * placeholder with index 
                        txt = ' I am {1} my age is {0}'.format(age, name)
                        print(txt)      # I am Protick my age is 28

                        element = '&lt;{0}> {1} &lt;/{0}>'.format('p', 'paragraph text')
                        print(element)  # &lt;p> paragraph text &lt;/p>
                        
                    * with dictionary
                        person = { 'name': 'Protick', 'age': 28 }
                        txt = 'I am {0[name]} my age is {1[age]}'.format(person, person)
                        or, 
                        txt = 'I am {0[name]} my age is {0[age]}'.format(person)
                        print(txt)      # I am Protick my age is 28

                    * with list
                        info = ['Protick', 28]
                        txt = 'I am {0[0]} my age is {0[1]}'.format(info)
                        print(txt)      # I am Protick my age is 28

                    * with object attributes 
                        class Person():
                            def __init__(self, name, age):
                                self.name = name
                                self.age = age 

                        p1 = Person('Protick', 28)
                        txt = 'I am {0.name} my age is {0.age}'.format(p1)
                        print(txt)      # I am Protick my age is 28

                    * with keyword argument 
                        txt = 'I am {name} my age is {age}'.format(name='Protick', age=28)
                        print(txt)      # I am Protick my age is 28

                        * dictionary unpacking to generate keyword arguments 
                            person = {'name': 'Protick', 'age': 28}
                            txt = 'I am {name} my age is {age}'.format(**person)
                            print(txt)      # I am Protick my age is 28

                    * number formatting 
                        1. add padding to number in a placeholder   
                            txt = '{0:02}'.format(8)
                            print(txt)      # '08'
                            
                        2. digits after decimal point of a float 
                            txt = '{0:.4f}'.format(3.141592)
                            print(txt)      # 3.1416

                            * also perfomrs approximation

                        3. add comma seperator and digits after decimal point to a number 
                            txt = '{0:,.2f}'.format(10000000)
                            print(txt)      # 10,000,000.00
                            

                    * data formatting 
                        with a date object 
                            from datetime import datetime
                            a = datetime(2022, 1, 11)
                            birthday = '{0:%B %d, %Y}'.format(a)
                            print(birthday)     # January 11, 2022
                    
                    *** There must not be any whitespace between placeholder curly braces and the
                        formatting string 
                            e.g., 
                                '{ 0:02 }'.format(7) ❌
                            right form would be, 
                                '{0:02}'.format(7) ✔

                
                3. f'string 

        </p>

        <h2>Built in functions</h2>
        <p> 
            functions that can be used directly without importing anything or using any namespace
            * dir()
                dir(varaible)
                returns all methods and attributes that we have access to when using a variable
    
            * help()
                help(str)
                returns doc string of a class           
                
            
            * absolute value - abs() 
                abs(-15))               # 15

            * round to nearest int or float 
                * nearest int 
                    round(10.6))        # 11
                 
                * round to nearest float 
                    round to 1 decimal place
                    round(10.65, 1))    # 10.7

            * built in function to retrieve object's memory location - id() 
                num = 10
                print(id(num))  # 2960035414544

            * min(), max(), sum() 
                returns minium, maximum and sum of a sequence 
                    nums = [1, 2, 4, 3, 5]
                    * min(nums)   # 1
                    * max(nums)   # 5
                    * sum(nums)   # 15
            
            * pow(base, exponent)
                pow(2, 10)  # 1024 
        </p>

        <h2>Operators</h2>
        <p>
            * arithmatic operators
                num_1 = 10
                num_2 = 3

                * parenthesis
                    (num_1 * 2) * num_2     # 60

                * exponentiation
                    num_1 ** num_2          
                    # 10 to the power of 3 = 10 * 10 * 10 == 1000

                * multiplication 
                    num_1 * num_2           # 30

                * divisoin 
                    num_1 / num_2   
                    # in python 3,      10 / 3 == 3.3333333333333335
                    # in python 2,      10 / 3 == 3

                * floor division 
                    num_1 // num_2          # 10 // 3 == 3

                * remainder operator
                    num_1 % num_2           # 10 % 3 == 1 

                * addition 
                    num_1 + num_2           # 10 + 3 == 13

                * substraction 
                    num_1 - num_2           # 10 - 3 == 7

                * arithmatic operator precendence order 
                    Parenthesis Exponentiation Multiplication Division Addition Substraction
                    PEMDAS



            * Comparison operator 
                ==, !=, >, &lt;, >=, &lt;=

                num_1 = 10
                num_2 = 3

                * equal 
                     num_1 == num_2     # 10 == 3 ? False 

                * not equal 
                    num_1 != num_2      # 10 != 3 ? True

                * greater than 
                    num_1 > num_2       # 10 > 3 ? True

                * less than 
                    num_1 &lt; num_2       # 10 &lt; 3 ? False

                * greater than or equal 
                    num_1 >= num_2      # 10 >= 3 ? True

                * less than or equal 
                     num_1 &lt;= num_2     # 10 &lt;= 3 ? False



            * assignment and compound assignment operator 

                * (assignment ) operator 
                    num = 10

                * compound assignemnt operators 
                    num += 1
                    num = num + 1 == 11

                    num **= 2
                    num = num ** 2 
                    num = 10 ** 2
                    num = 100

                    * similerly,  
                        -=, *=, /=, //=, %=, **= 

            
            * logical operators 
                and, or, not


            * membership operator 'in'
                checks if a value is present in an object, iterables
                e.g., 
                    nums = [ 1, 2, 3, 4]
                    val = 3
                    if val in nums: 
                        print(f'{val} is present in the list')

            * identity operator 'is'
                checks if two variable references to the same object in memory
                    a = [1, 2, 3]
                    b = [1, 2, 3]
                
                    1. 
                        print(a is b) False 
                        print( a == b) True
            
                    2.
                        a = b 
                        print( a is b)
                        True

            * bit-wise operator 
                &, |, ^, ~ &lt;&lt;, >>
                Left and right shift are zero fills 
                Right shift is signed

            * Operator precedence 
                ()
                **      [Associativity: right to left]
                +var 
                -var 
                ~var 
                * 
                / 
                // 
                % 
                + 
                - 
                &lt;&lt; 
                >> 
                & 
                ^ 
                | 
                Comparison 
                Identity 
                Membership 
                not 
                and 
                or

                Assignment "=" and comparison operator does not have associativity 
                Rest of them have associativity of left to right 
        </p>

        <h2>Conditionals, True and False values, Match statement </h2>
        <p>
            * Boolean values - '&lt;class 'bool'&gt;'
                1. True 
                2. False

            * False Values 
                1. False
                2. None
                3. Zero of any numeric type i.e., int, float, 
                4. empty sequence such as empty tuples(), lists [], strings ""
                5. epmty mappings such as dictionaries {}, sets {}
                
            * True values 
                except for False values everything else is True
                
                
            * if elif else
                if condition_1: 
                    'condition 1 is true'
                elif condition_2:
                    'conditon_1 is false and condition_2 is true' 
                else: 
                    'condition_1 and condition_2 are false'

            * ternary operator 
                statement a if True else b


            * Match statement 
                A match statement takes an expression and compares its value to successive patterns given as one 
                or more case blocks Only the first pattern that matches gets executed and it can also extract 
                components (sequence elements or object attributes) from the value into variables.

                    def http_error(status):
                        match status:
                            case 400:
                                return "Bad request"
                            case 404:
                                return "Not found"
                            case 418:
                                return "I'm a teapot"
                            case _:
                                return "Something's wrong with the internet"

                * _ acts as a wildcard and never fails to match deafult case.
                    If no case matches, none of the branches is executed.

                * You can combine several literals in a single pattern using | (“or”):
                    case 401 | 403 | 404:
                        return "Not allowed"

                * Patterns can look like unpacking assignments, and can be used to bind variables:
                    # point is an (x, y) tuple
                    match point:
                        case (0, 0):
                            print("Origin")
                        case (0, y):
                            print(f"Y={y}")
                        case (x, 0):
                            print(f"X={x}")
                        case (x, y):
                            print(f"X={x}, Y={y}")
                        case _:
                            raise ValueError("Not a point")

                    1. The first pattern has two literals, and can be thought of as an extension of the literal 
                        pattern shown above. 

                    2. But the next two patterns combine a literal and a variable, and the variable binds a value 
                        from the subject (point).

                    3. captures two values, which makes it conceptually similar to the 
                        unpacking assignment (x, y) = point.


                * If you are using classes to structure your data you can use the class name followed by an argument 
                    list resembling a constructor, but with the ability to capture attributes into variables:

                    class Point:
                        x: int
                        y: int

                    def where_is(point):
                        match point:
                            case Point(x=0, y=0):
                                print("Origin")
                            case Point(x=0, y=y):
                                print(f"Y={y}")
                            case Point(x=x, y=0):
                                print(f"X={x}")
                            case Point():
                                print("Somewhere else")
                            case _:
                                print("Not a point")

                * Look at them as an extended form of what you would put on the left of an assignment, 
                    to understand which variables would be set to what. 
                    
                    Only the standalone names (like var above) are assigned to by a match statement. 
                    Dotted names (like foo.bar), attribute names (the x= and y= above) or class names (recognized 
                    by the “(…)” next to them like Point above) are never assigned to.


                * Patterns can be arbitrarily nested. For example, if we have a short list of points, 
                    we could match it like this:

                    match points:
                        case []:
                            print("No points")
                        case [Point(0, 0)]:
                            print("The origin")
                        case [Point(x, y)]:
                            print(f"Single point {x}, {y}")
                        case [Point(0, y1), Point(0, y2)]:
                            print(f"Two on the Y axis at {y1}, {y2}")
                        case _:
                            print("Something else")
                    

                * We can add an if clause to a pattern, known as a “guard”. If the guard is false, match goes 
                    on to try the next case block. Note that value capture happens before the guard is evaluated:

                    match point:
                        case Point(x, y) if x == y:
                            print(f"Y=X at {x}")
                        case Point(x, y):
                            print(f"Not on the diagonal")


                * Several other key features of this statement:
                    Like unpacking assignments, tuple and list patterns have exactly the same meaning and 
                    actually match arbitrary sequences. An important exception is that they don't match iterators 
                    or strings.
                    
                    * Sequence patterns support extended unpacking: [x, y, *rest] and (x, y, *rest) 
                        work similar to unpacking assignments. The name after * may also be _, so (x, y, *_) 
                        matches a sequence of at least two items without binding the remaining items.
                    
                    * Mapping patterns: {"bandwidth": b, "latency": l} captures the "bandwidth" and "latency" 
                        values from a dictionary. Unlike sequence patterns, extra keys are ignored. An unpacking 
                        like **rest is also supported. (But **_ would be redundant, so it is not allowed.)
                    
                        * Subpatterns may be captured using the as keyword:
                    
                            case (Point(x1, y1), Point(x2, y2) as p2): ...
                            will capture the second element of the input as p2 (as long as the input is a 
                            sequence of two points)
                            
                    * Most literals are compared by equality, however the singletons True, False 
                        and None are compared by identity.
                    
                    * Patterns may use named constants. These must be dotted names to prevent them 
                        from being interpreted as capture variable:
                    
                            from enum import Enum
                            class Color(Enum):
                                RED = 'red'
                                GREEN = 'green'
                                BLUE = 'blue'
                            
                            color = Color(input("Enter your choice of 'red', 'blue' or 'green': "))
                            
                            match color:
                                case Color.RED:
                                    print("I see red!")
                                case Color.GREEN:
                                    print("Grass is green")
                                case Color.BLUE:
                                    print("I'm feeling the blues :(")

                
        </p>

        <h2>Python Builtin Data Structures</h2>
        <p>
            <strong>Lists</strong>  
            list is a collection of elements. list is not actually array because list can have heterogenous 
            data as list element. takes a lot more space than arrays 
            array.array and numpy.ndarray are arrays. 

            lists can have different types of data as element. 
                1. lists can have lists as elements
                2. list can have dict as elements 
                3. list can have all of the above at the same list at the same time. 
                4. list retains order 
                5. lists are mutable

            declaraing a list 
                1. students = []
                2. students = list()
                type(students)  # &lt;class 'list'&gt;
                
                
            * list methods 
                courses = ['Bangla', 'English', 'Math']
            
                * length of a list
                    len(courses)        # 3
                    
                * access list element by index
                    courses[1]          # English
                    
                * access list item by negative index 
                    negative index starts from -1 from the end of a list
                    courses[-1]         # Math
                    
                * update list element by index 
                    courses[-1] = 'Mathematics'
                    print(courses)      # ['Bangla', 'English', 'Mathematics']
                    
                * list slicing / new list from a list by start index (inclusive) and end index ( not inclusive ) 
                    new_list = courses[ 1 : 2 ]
                    print(new_list)     # ['English']
                    
                    * omitting start index will default to 0 
                        courses[:2]         # ['Bangla', 'English']
                        
                    * omitting end index will return all elements including the last element of a list
                        courses[0:]         # ['Bangla', 'English', 'Math']
                        
                    
                * list.append(value)
                    append new element at the end of a list 
                        courses.append('History')
                        print(courses)      # ['Bangla', 'English', 'Math', 'History']
                        
                * list.insert(index, value)
                    append element at the specified index and shifts the current element and the consecutive 
                    elements to the right 
                    the 'value' can also be a list and in that case it will be placed in the list as an element
                        courses.insert(1, 'History')
                        print(courses)      # ['Bangla', 'History', 'English', 'Math']

                    * If index is out of range then inserts value at the last of the list. 
                        
                    
                * list.extend([new, list])
                    unpacks the extend's argument into seperate elements and append them to the list 
                        new_courses = ['History', 'Physics']
                        courses.extend(new_courses)
                        print(courses)      # ['Bangla', 'English', 'Math', 'History', 'Physics']
                        
                * list.pop(index)
                    * pops last value from a list if index argument is not passed
                        popped_value = courses.pop()
                        print(popped_value)     # Math

                    * pop value from a list by index
                        print(courses.pop(-2))  # English
                        print(courses)          # ['Bangla', 'Math']
                    
                * list.remove(value)
                    removes a value from a list 
                        res = courses.remove('English')
                        print(res)      # None
                        print(courses)  # ['Bangla', 'Math']
                    
                * list.reverse()
                    mutates the list and Reverse the elements of the list in place. 
                        courses.reverse() 
                        print(courses)  # ['Math', 'English', 'Bangla']
                        
                * list.sort() 
                    sorts in alphabetical or numerical order by default, sorts in place 
                    meaning it mutates the original list
                        courses.sort()
                        print(courses)  # ['Bangla', 'English', 'Math']
                
                * list.copy()
                    Return a shallow copy of the list meaning nested elements will not be copied. 
                    Equivalent to courses[:]
                        courses_copy = courses.copy()    
                        print(id(courses), courses)           # 2373837887232 ['Bangla', 'English', 'Math']
                        print(id(courses_copy), courses_copy)   # 2373837985600 ['Bangla', 'English', 'Math']
                        
                * list.count()
                    returns the number of entries of an element in a list or 0 if not present
                    courses.count("Bangla")     # 1
                    courses.count("Biology")    # 0
                    
                * list.index()
                    retunrns the index of an element in a list or exception if not found
                        courses.index("English") # 1
                        courses.index("Biology") # ValueError: 'Biology' is not in list
                    
                * del list[index]
                    deletes item from a list at provided index
                        del courses[1]
                        print(courses)  # ['Bangla', 'Math']
                        
                * list.clear()
                    deletes all elements from an array
                        courses.clear()
                        print(courses)  # []
                        
                * list to string 
                    courses_str = ', '.join(courses)
                    print(courses_str)  # Bangla, English, Math
                    
                * string to list 
                    courses_from_str = courses_str.split(', ')
                    print(courses_from_str)     # ['Bangla', 'English', 'Math']




            <strong>Tuples</strong>
            A tuple consists of a number of values separated by commas
            Though tuples may seem similar to lists, they are often used in different situations 
            and for different purposes. Tuples are immutable, and usually contain a heterogeneous 
            sequence of elements that are accessed via unpacking or indexing or even by attribute in 
            the case of namedtuples. 
            Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list.
        
            declaraing a tuple 
                1. months = ()
                2. months = tuple()
                type(months)                    # &lt;class 'tuple'&gt;


            * single element tuple 
                new_tuple = (123,)
                print(new_tuple)                # (123,)

            * empty tuple 
                months = ()
                print(months, type(months))     # () &lt;class 'tuple'&gt;

            * packing 
                t = 12345, 54321, 'hello!'
                print(t, type(t))               # (12345, 54321, 'hello!') &lt;class 'tuple'&gt;

            * unpacking 
                t = 12345, 54321, 'hello!'
                a, b, c = t
                print(a, b, c)  # 12345 54321 hello!


            new_tuple = (12345, 54321, 'hello!')

            * retrieving tuple elements by index
                print(new_tuple[-1])    # hello!

            * assignment operation using tuple index throws error 

            * tuple methods 
                * tuple.count(value)
                    returns number of times an element is present in the tuple
                        print(new_tuple.count("hello!"))    # 1

                * tuple.index()
                    returns index of an element in a tuple or exception
                    print(new_tuple.index('hello!'))    # 2
                    print(new_tuple.index('welcome'))   # ValueError: tuple.index(x): x not in tuple

                * two tuples can be concatenated by + operation 
                    extended_tuple = new_tuple + (1, 2, 3)
                    print(extended_tuple)   # (12345, 54321, 'hello!', 1, 2, 3)

                * tuple initialization 
                    nt = ('hi', ) * 5
                    print(nt)   # ('hi', 'hi', 'hi', 'hi', 'hi')
                    interesting but I do not know where to use this technique




            <strong>Sets</strong>
            Python also includes a data type for sets. A set is an unordered collection 
            with no duplicate elements. Basic uses include membership testing and eliminating 
            duplicate entries.

            Set objects also support mathematical operations like union, intersection, difference, 
            and symmetric difference.

            Curly braces or the set() function can be used to create sets. 
            Note: to create an empty set you have to use set(), not {}

            sets are mutable but an immutable set can be generated by using frozenset()
            sets are optimized to use membership operator( in )


            declaraing a set 
                1.  species = { 'Homo habilis', 'Homo rudolfensis', 'Homo erectus', 'Homo antecessor' }
                    species = {} will create an empty dictionary not a set.                     
                2.  species = set()
                type(species)   # &lt;class 'set'&gt;

                * as sets are unordered/unindexed we can not access it by index 

            * set methods
                new_set = { 1, 2, 3, 4, 5, 3, 4, 6 }
                print(new_set)      # {1, 2, 3, 4, 5, 6}

                * set.add(new_element)
                    adds a new_element to the set
                        new_set.add(7)
                        print(new_set)      # {1, 2, 3, 4, 5, 6, 7}

                * set.remove(element)
                    removes element if exists or else throws an Exception
                        new_set.remove(6)
                        print(new_set)      # {1, 2, 3, 4, 5}
                        new_set.remove(7)
                        KeyError: 7

                * set.discard(element)
                    removes element from a set if it exists or does nothing if not. 
                        new_set.discard(7)
                        print(new_set)      # {1, 2, 3, 4, 5, 6}

                * set.pop()
                    pops and returns random element from the set
                        x = new_set.pop()
                        print(x, new_set)   # 1 {2, 3, 4, 5, 6}

                * set.clear()
                    removes all elements from a set and returns NoneType object, mutates the set
                        new_set.clear()
                        
                * del set()
                    deletes set from context
                        del new_set

                * create set from a list 
                    set_from_list = set([1, 2, 3, 4, 5, 1, 2])
                    print(set_from_list)    # {1, 2, 3, 4, 5}

                * craete list from a set
                    list_from_set = list(set_from_list)
                    print(list_from_set)
                    [1, 2, 3, 4, 5]


                * set operations
                    returns a new result set; does not modify operands

                    a = { 1, 2, 3 }
                    b = { 3, 4, 5 }

                    * union
                        print(a.union(b))           # {1, 2, 3, 4, 5}

                    * intersection
                        print( a.intersection(b))   # {3}

                    * in a but not in b ( difference )
                        print( a.difference(b))     # {1, 2}

                    * symbolic difference 
                        print(a.symmetric_difference(b))    # {1, 2, 4, 5}

                    * a.isdisjoint(b), a.issubset(b), a.issuperset(b) methods are also available




            <strong>Dictionaries</strong>
            Dictionary is an unordered collection of key value pairs where value can be anything and 
            dictionaries are indexed by keys, which can be any immutable type; 
            strings and numbers can always be keys. 
            Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple 
            contains any mutable object either directly or indirectly, it cannot be used as a key. 
            You can't use lists as keys, since lists can be modified in place using index assignments, 
            slice assignments, or methods like append() and extend().
            It is best to think of a dictionary as a set of key: value pairs, 
            with the requirement that the keys are unique (within one dictionary).

            * declaraing a dictionary 
                1. student = {}
                2. student = dict()
                3. The dict() constructor builds dictionaries directly from sequences of key-value pairs

                print(type(student))    # &lt;class 'dict'&gt;


            john = { 'name': 'John', 'age': 28, 'country': 'Bangladesh' }
            
            * access dictionary entries
                * dict_obj[key]
                    returns value against a key or throws a KeyError if key does not exist
                        print(john['name'])     # John

                * inserting or updating a new entry 
                    john['age'] = 27
                    print(john)     # {'name': 'John', 'age': 27, 'country': 'Bangladesh'}
                    
                * insert value against a key
                    john['language'] = 'Bangla'
                    print(john)     # {'name': 'John', 'age': 28, 'country': 'Bangladesh', 'language': 'Bangla'}




            * dictionary methods
                * dict.get(key, default_value)
                    returns None or default value if key does not exist or the value at the key if it exists
                        *   print(john.get('name'))         # John
                            print(john.get('language'))     # None
                            
                        *   print(john.get('language', 'Bangla')) # Bangla

                * dict.update({})
                    insert and update entries of a dictionary 
                    inserts new key: value pair if key does not exist in dictionary or update if key exists 
                        john.update({'language': 'Bangla', 'country': 'Heaven'})
                        print(john)     # {'name': 'John', 'age': 28, 'country': 'Heaven', 'language': 'Bangla'}

                * dict.pop(key)
                    pops and returns value from a dictionary against the provided key or 
                    throws KeyError if key does not exist
                        x = john.pop('age')
                        print(x)    # 28

                        x = john.pop('language')
                            KeyError: 'language'

                * dict.keys()
                    returns a list of keys 
                        keys = john.keys()
                        print(keys)     # dict_keys(['name', 'age', 'country'])

                * dict.values()
                    returns a list of values 
                        values = john.values()
                        print(values)   # dict_values(['John', 28, 'Bangladesh'])

                * dict.items()
                    returns a list of tuples (key, value) 
                        items = john.items()
                        print(items)    # dict_items([('name', 'John'), ('age', 28), ('country', 'Bangladesh')])

                * dict.popitem()
                    pops and returns last key value as a tuple: (key, value) 
                        last = john.popitem()
                        print(last)     # ('country', 'Bangladesh')

                * dict.clear()
                    cleares dictionary
                        d = john.clear()
                        print(d, john)  # None {}

                * len(dict_obj)
                    returns length of a dictionary object 
                        len(john)       # 3

                * del dict_obj[key]
                    deletes key: value from a dictionary 
                        del john['age']
                        print(john)     # {'name': 'John', 'country': 'Bangladesh'}
        </p>

        <h2>Slicing, Sorting, Comprehension</h2>
        <p>
            <strong>Slicing</strong>
            extract certain elements from lists and strings 
            
            * Lists and Strings 
                nl = [0,   1,   2,  3,  4,  5,  6,  7,  8,  9]
                      0,   1,   2,  3,  4,  5,  6,  7,  8,  9 -> positive index
                    -10,  -9,  -8, -7, -6, -5, -4, -3, -2, -1 -> negative index
            
                * retrieving same element of the list using positive and negative index 
                    print(nl[0], nl[-10])   # 0 0

                * print(nl[1:-1:2])         # [1, 3, 5, 7]
                    nl[start:end:step]
                        start from index 1 end at index -1 (not inclusive) with step size of 2 meaning 
                        take every second element of the list extracted by start:end == 1:-1
                    

                * print(nl[3::])            # [3, 4, 5, 6, 7, 8, 9]
                    start from index 3 and take all elements including the last 
                    

                * print(nl[:9])             # [0, 1, 2, 3, 4, 5, 6, 7, 8]
                    start index is not given so start from 0 and upto index 9 (not inclusive)
                    

                * we can also use negative step size. In that case list element extraction will start from the 
                    opposite of the default direction (which is left to right)

                        print(nl[-1:1:-1])  # [9, 8, 7, 6, 5, 4, 3, 2]

                        print(nl[1:9:-1])   # []
                            you can not just go to index 9 from index 1 at reverse order 

                * reversing a list 
                    print(nl[::-1])         # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

                * slicing also applies to strings same as lists
            
            <strong>Comprehension</strong>
            * List 
                nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]
                
                1.  my_list = [ item for item in nums ]
                    print(nums, my_list)        # [1, 2, 3, 4, 5, 6, 7, 8, 9]    [1, 2, 3, 4, 5, 6, 7, 8, 9]

                2.  my_list = [ n * n for n in nums ]
                    print(my_list)              # [1, 4, 9, 16, 25, 36, 49, 64, 81]
                       
                    * lambda function equivalent of the last list comprehension
                        my_list = list(map(lambda x: x * x, nums))
                        print(my_list)          # [1, 4, 9, 16, 25, 36, 49, 64, 81]

                3.  my_list = [ n for n in nums if n % 2 == 0 ]
                    print(my_list)              # [2, 4, 6, 8]

                4.  nested for loops in list comprehension 
                        my_list = [(letter, num) for letter in 'abc' for num in range(2)]
                        print(my_list)          # [('a', 0), ('a', 1), ('b', 0), ('b', 1), ('c', 0), ('c', 1)]

                
            * Dictionary
                    names = [ 'Peter', 'Bruce', 'Clerk', 'Jhony']
                    heroes = [ 'Spiderman', 'Batman', 'Superman', 'Jack Sparrow' ]

                    my_dict = { name: hero for name, hero in zip(names, heroes) if name != 'Peter'}
                    print(my_dict)      # {'Bruce': 'Batman', 'Clerk': 'Superman', 'Jhony': 'Jack Sparrow'}


            * Set
                nums = [1, 2, 3, 4, 5, 6, 3, 4, 5, 7, 8, 9]
                my_set = { n for n in nums }
                print(my_set)           # {1, 2, 3, 4, 5, 6, 7, 8, 9}

            
            * generator expression 
                nums = [1, 2, 3, 4]
                my_gen = (n * n for n in nums)
                print(type(my_gen))         # &lt;class 'generator'&gt;

                    1. convert generator to list 
                        print( list(my_gen))        # [1, 4, 9, 16]

                    2. loop over a generator
                        for n in my_gen: 
                            print(n)                # 1 4 9 16 each element on a new line
            

            * tuple 
                there is no syntax for tuple comprehension but you can do it with tuple() constructor 
                combined with generator expression 
                
                    my_tup = tuple(my_gen)
                    print(my_tup)       # (1, 4, 9, 16)


            <strong> Sorting </strong>
            Lists 
                li = [1, 2, 3, 4]

                1. using list.sort() 
                    li.sort()
                        sorts list in place mutating the original list 
                        returns None as return value 
                        sorts in ascending order by default 

                    li.sort(reverse=True)
                        sorts in descending order 

                2. using sorted() function 
                    nli = sorted(li) 
                        returns a new sorted list 
                        sorts in ascending order by default 

                    nli = sorted(li, reverse=True)
                        sorts in descending order 

                * sort() method is not available on any other sequence type objects other than lists 
                * tuples, sets and dictionaries can be sorted using sorted() method 

            Dictionary 
                1. sd = sorted(dict_obj)
                    sorts the dict_obj based on the keys and returns the sorted dictionary  


            * sorted also accepts a keyword argument 'key' which takes a function as a value 
                the value returned by that function will be used during sorting the sequence 
                
                li = [-6, -5, -4, 1, 2, 3]
                
                to sort li list based on absoulte value of the elements we can pass builtin abs function as 
                key value 
                    nli = sorted(li, key=abs)

            Objects 
                1. sort using a custom sorter function 
                    class Employee():
                        def __init__(self, name, age):
                            self.name = name
                            self.age = age 
                
                    def sorter_func(emp):
                        return emp.age
                    
                    
                    e1 = Employee('Corey', 26)
                    e2 = Employee('Jonas', 24)
                    emps = [e1, e2]
                    
                    sorted_emps = sorted(emps, key=sorter_func)
                    print(sorted_emps[0].age, sorted_emps[1].age)   # 24 26
                    
                2. sort using builtin attrgetter function 

                    from operator import attrgetter 
                    sorted_emps = sorted(emps, key=attrgetter('age'))
                    print(sorted_emps[0].age, sorted_emps[1].age)   # 24 26
        </p>

        <h2>Loops</h2>
        <p>
            <strong>for</strong> 
                nums = [1 , 2, 3, 4, 5]
                * with sequence or collection datas
                    for num in nums: 
                        print(num)  # 1 2 3 4 5 [each element on a new line]

                * with range(start, stop)
                    * range(stop) == range(0, stop)
                        1. returns an iterable which starts from start value (inclusive)  and 
                            stops at end value (not inclusive)
                        2. if single value is passed as an argument then start value becomes 0
                        
                    for i in range(1, 6):
                        print(i)    # 1 2 3 4 5 [each element on a new line]




            <strong>while</strong> 
                x = 0
                while x &lt; 10: 
                    print(x)
                    x += 1
                
                # 0 1 2 3 4 5 6 7 8 9 [each element on a new line]


                * infinite loop
                    x = 0
                    while True: 
                        x += 1
                        if x == 4: 
                            continue
                        if x == 5:
                            break
                        print(x)

                    # 1 2 3 [each element on a new line]
            


            <strong>else clause on loops </strong> 
                The else clause is executed if you exit a block normally, by hitting the loop 
                condition or falling off the bottom of a try block. 
                It is not executed if you break or return out of a block, or raise an exception. 
                It works for not only while and for loops, but also try blocks.

                You typically find it in places where normally you would exit a loop early, and running 
                off the end of the loop is an unexpected/unusual occasion. For example, if you're looping 
                through a list looking for a value:

                    values = [ 1, 2, 3, 4, 5, 6]
                    for value in values:
                        if value == 5:
                            print("Found it!")
                            break
                    else:
                        print("Nowhere to be found. :-(")
        </p>

        <h2>Function</h2>
        <p>
            def func():
                ''' Doc string '''
                print('Func function is called')
                return True
            
            1. The keyword def introduces a function definition. It must be followed by the function name and 
                the parenthesized list of formal parameters.
            2. The first statement of the function body can optionally be a string literal; 
                this string literal is the function's documentation string, or docstring
            3. The execution of a function introduces a new symbol table used for the local variables of the function. 
                More precisely, all variable assignments in a function store the value in the local symbol table
            
            * Scope chain 
                variable look up happens in the following order,  
                    1. local symbol table 
                    2. local symbol tables of enclosing functions 
                    3. global symbol table 
                    4. table of built-in names
                * LEGB Rule: Local, Enclosed, Global, Builtins

                Note 1:
                Thus, global variables and variables of enclosing functions cannot be directly 
                assigned a value within a function (unless, for global variables, named in a global statement, 
                or, for variables of enclosing functions, named in a nonlocal statement), 
                although they may be referenced (their value can be retrieved)

            * How Arguments (Actual Parameters) and Parameters (Formal Parameters)  are Stored 
                1. The actual parameters (arguments) to a function call are introduced in the local symbol table of the 
                    called function when it is called; thus, arguments are passed using call by value (where the value 
                    is always an object reference, not the value of the object).
                2. When a function calls another function, or calls itself recursively, a new local symbol table is 
                    created for that call.

            * Functions are objects 
                A function definition associates the function name with the function object in the current symbol table. 
                The interpreter recognizes the object pointed to by that name as a user-defined function. 
                Other names can also point to that same function object and can also be used to access the function
            
            * Return Value
                The return statement returns with a value from a function. 
                Even functions without a return statement do return a value, This value is called None 
                Falling off the end of a function also returns None.

            * How default argument values are stored
                Note 2: 
                The default values are evaluated at the point of function definition in the defining scope, so that
                def f(arg=i) says "make me a function f where the default value for arg is whatever i is right now". 
                At the time of defining the function, i=5.

                *** The default values are evaluated at the point of function definition 
                    in the defining scope, so that
                    i = 5
                    def f(arg=i):
                        print(arg)

                    i = 6
                    f()
                    will print 5

                *** Important warning: The default value is evaluated only once. This makes a difference when 
                    the default is a mutable object such as a list, dictionary, or instances of most classes. 
                    For example, the following function accumulates the arguments passed to it on subsequent calls:

                        def f(a, L=[]):
                            L.append(a)
                            return L
                        
                        print(f(1))
                        print(f(2))
                        print(f(3))

                        This will print
                        [1]
                        [1, 2]
                        [1, 2, 3]

                    because the default argument L ponts to a list object which is created at the time of function 
                    definition.

                    Note 3: 
                    when the function definition was executed and the execution result was stored in 
                    memory as a function object to which the name 'f' refers to. In that function object's local scope 
                    a variable was defined named 'L' which were assigned a value to a list object which is 
                    stored in somewhere else in the memory.

                    * To do not fall into this pitfall you can omit using mutable objects as 
                        default value to a parameter or you can do the following, 

                        def f(a, L=None):
                            if L is None:
                                L = []
                            L.append(a)
                            return L

            * Positonal and Keyword arguments and optional parameter
                def func(pos_arg, kwarg_1='No value', kwarg_2=True):
                    print(pos_arg, kwarg_1, kwarg_2)
            
                func('Required Positional Argument',
                    kwarg_1='keyword argument for optional parameter kwarg_1')
    
                    this will print, 
                        Required Positional Argument keyword argument for optional parameter kwarg_1 True
                
                In this exmaple,
                1. 'pos_arg' is a required positional parameter ( / formal argument) 
                2. 'kwarg_1' and 'kwarg_2' are optional parameters (/ formal arguments )
                3. when we are calling the function, 
                    the value passed at the first position is a positional argument and it is required
                    in the second position, we are passing a keyword argument 'kwarg_1' = 'value'
                    for the third, we did not pass any arguments and that is okay because it is optional. 

            * Rules for passing arguments 
                    1. all keyword arguments must come after all positional arguments from left to right 
                        or it will throw exception 

                    2. value to a positional parameter can also be passed with a keyword argument.
                        for the previous example, we can pass value to positional parameter 'pos_arg' by, 

                            func(pos_arg = 'Required Positional Argument') and it will work.

                    3. All the keyword arguments passed must match one of the arguments accepted by the function, 
                        and their order is not important. This also includes non-optional arguments.

                            func(kwarg_1 = 'keword arg', pos_arg = 'pos arg')
                            output:  pos arg keword arg True

                    4. No argument may receive a value more than once.
                        for the previous example, 
                            func('This is for required positional parameter', pos_arg = 'Required Positional Argument')

                            this function call will throw an error as we are passing two arguments for one parameter, 
                            1 positional argument and 1 keyword argument.
                            Error: func() got multiple values for argument 'pos_arg'


            * Special parameters
                Keyword parameters are also referred to as named parameters.
                By default, arguments may be passed to a Python function either by position or explicitly by keyword. 
                To restrict the way arguments can be passed,

                A function definition may look like:
                
                    def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
                        -----------    ----------     ----------
                            |             |                  |
                            |        Positional or keyword   |
                            |                                - Keyword only
                            -- Positional only

                where / and * are optional.

                1. Positional-only parameters are placed before a / (forward-slash).
                    If positional-only, the parameters' order matters, and the parameters cannot be passed by keyword.
                    If there is no / in the function definition, there are no positional-only parameters.

                2. Parameters following the / may be positional-or-keyword or keyword-only.
                
                3. To mark parameters as keyword-only, indicating the parameters must be passed by keyword argument, 
                    place an * in the arguments list just before the first keyword-only parameter.

                Perks:
                    the names of positional-only parameters can be used in **kwargs without ambiguity.

                As guidance:
                    1. Use positional-only if you want the name of the parameters to not be available to the user. 
                        This is useful when parameter names have no real meaning, if you want to enforce the order 
                        of the arguments when the function is called or if you need to take some positional parameters 
                        and arbitrary keywords.
                    2. Use keyword-only when names have meaning and the function definition is more understandable by 
                        being explicit with names or you want to prevent users relying on the position of the argument 
                        being passed.
                    3. For an API, use positional-only to prevent breaking API changes if the parameter's name is 
                        modified in the future.



            * Arbitrary Argument Lists - argument packing 
                1. Final formal parameter of the form *name which receives a tuple containing the positional 
                    arguments beyond the formal parameter list. 
                2. Final formal parameter of the form **name is present, it receives a dictionary containing 
                    all keyword arguments except for those corresponding to a formal parameter. 
                3. *name must occur before **name.

                def func(pos, kwarg='val', *args, **kwargs)
                    *args packs all the arguments which are passed beyond all the positional parameters in a tuple
                    **kwargs packs all the keyword arguments which are passed beyond all the keyword parameters 
                        in a dictionary

            
            * Unpacking Argument Lists
                1. unpacking a tuple and use elements as positional arguments
                    *(1, 10) is equivalent to 1, 10

                2. unpacking a dictiona ans use key:value pair as keyword arguments 
                    **{'name': 'John', 'age': 25} is equivalent to  name='john', age=25


            * Lambda Expressions
                Small anonymous functions can be created with the lambda keyword. This function returns the sum of 
                its two arguments: lambda a, b: a+b.
                They are syntactically restricted to a single expression. Semantically, they are just syntactic 
                sugar for a normal function definition. 
                Like nested function definitions, lambda functions can reference variables from the containing scope:

                    def make_incrementor(n):
                        return lambda x: x + n
                    
                    f = make_incrementor(42)

            * Documentation Strings
                in short doc string describes an objects purpose, parameter, return value , exception type etc. 


            * Function Annotations
                Function annotations are completely optional metadata information about the types used 
                by user-defined functions

                    1. Parameter annotations are defined by a colon after the parameter name, followed by an 
                        expression evaluating to the value of the annotation. 

                    2. Return annotations are defined by a literal ->, followed by an expression, between the parameter 
                        list and the colon denoting the end of the def statement


            * skip body implementation by using pass keyword
                def func():
                    pass 

            * functions with positional arguments
                def hello_func(name, greetings):
                    print(f'{greetings } { name }!')

                hello_func('Protick', 'Hi')     # Hi Protick!

            * variable's scope chain, global and nonlocal statements

                x = 'global x'
                y = 'global y'
                def outer():
                    global x 
                    x = 'outer x'
                    y = 'outer y'
                
                    def inner():
                        # nonlocal x
                        nonlocal y 
                        y = 'inner y'
                        x = 'inner x'
                        print(x, y)
                    
                    inner()
                    print(x, y)
                
                outer()
                print(x, y)
                
                Variable scope 
                    where our variable can be accessed from within the program and what values those variables 
                    hold in differnt contexts 
                
                    1. Local Scope 
                        variable defined within a function body is called local variable and it is not 
                        accessible outside of the function body or from the global scope 

                    2. Global scope 
                        variable defined in the top level of a module and also variable declared with 
                        the global keyword. Global variable is available within the local scope of a function 
                        which is defined in that global scope

                    3. Local variable with the same name as a global variable will override the the global 
                        variable within that local scope. 

                    4. Though global variable can be accessed within a local scope, we can not reassign that 
                        global variable. To reassign a global variable from within a local scope we have to 
                        declare that global variable as 
                            global var 
                            var = 'new value'
                        
                    5. function parameter exists within the function's local scope 
                    
                    6. Builtins scope 
                        to see all the built-in variables are defined and available in the global scope, 
                            import builtins 
                            print(dir(builtins))

                    7. Enclosing scope 
                        inner function closes on all the variable's of outer scope and that outer scope can be 
                        local scope of another function 
                        that local scope of the outer function is called enclosed scope

                        you can access variables from enclosing scope like you accessed global variable within 
                        a local scope. But to assign or change value of a variable from enclosing scope you have
                        to declare that variable as, 
                            nonlocal var 
                            var = 'new value' 

                Note
                * global and nonlocal statement for a single variable name should not be combined 
                    for that variable name's scope chain 
                * do not override builtin names even if you are not prohibited by python.
                * Python look up for a variable in the scope chain by the LEGB rule. It first look up for a 
                    variable in Local scope then goes to Enclosing Scope then goes to Global scope and then 
                    goes to Builtins scope. If it finds a variable in a scope it stops looking up further in
                    the scope chain. If it does not find the variable in the whole scope chain it throws 
                    a NameError exception.
                

        </p>
 
        <h2>Modules and standard library</h2>
        <p>
            Module 
                Python has a way to put definitions in a file and use them in a script or in an interactive
                instance of the interpreter. Such a file is called a module; definitions from a module can 
                be imported into other modules or into the main module
                A module is a file containing Python definitions and statements. The file name is the 
                module name with the suffix .py appended

                * Python searches for modules in the path list defined in sys.path
                * Currently executing file's path is also automatically added to the sys.path list. 

                * how to import a module 
                    all statements defined in a module are executed before it is actually imported into antoher module or scripts

                    1. import my_module 
                        you can use variable or functions defined in a module by 
                            module_name.variable 
                            module_name.function()

                    2. import my_module as mm 
                        'my_module' will be imported with the name 'mm'
                        mm.varible 
                        mm.function()

                    3. from my_module import variable, function 
                        only selected variable and function will be imported into a module other than the 
                        whole module 

                    4. from my_module import variable as var, function as func 
                        selected imports will be named as given while being imported 

                    5. from my_module import * 
                        imports everything from a module 
                        Not recommended as it convolutes the global namespace

                

        </p>

        <h2>Devlopment tools, package installer and Virtual environments</h2>
        <p>

            * Package installer for python - PIP 
                we can use this package manager tool to install, uninstall, upgrade packages/modules
                
                1. pip search package-name 
                    searches for a package with the given package-name and returns package list 

                2. pip list 
                    lists out packages installed for current environment 
                
                3. pip install package-name 
                    installs package named 'package-name' into the current environment 
                    
                4. pip install package-name=version 
                    install package with specified version 

                5. pip list --outdated (or -O)
                    lists out outdated packages installed in the current environment 

                6. pip install --upgrade (or -U) package-name 
                    upgrades a package to the latest version 
                    
                7. pip freeze > requirements.txt 
                    lists out currently installed packages in the active environment to requirements.txt file 

                8. pip instlal -r requirements.txt 
                    install all packages listed in the requirements.txt file to the currently active environment. 


            * virtual envirnments 
                python execution environment with chosen python interpreter and modules 
                there are many tools available to create a virtual environment such as venv, 
                virtualenv, pyenv, anaconda etc. 

                * virtualenv 
                    1. pip instlal virtualenv 

                    2. virtualenv virtaul-environment 
                        will create a virtual environment named 'virtaul-environment' with the system default 
                        python interpretor set as default interpreter for the newly created virtual environment 

                    3. virtualenv -p path/to/python/interpreter/executable virtual-environment 
                        will create a virtual environment which has its interpreter set to the specified interpreter
                    
                    4. Activate a virtual environment 
                        source virtual-environment-directory/bin/activate 

                    5. deactivate 
                        deactivates the currently active virtual environment 
                    
        </p>

        <h2>PEP 8 Coding styles</h2>
        <p>
            1. Use 4-space indentation, and no tabs.
            2. 4 spaces are a good compromise between small indentation (allows greater nesting depth) 
                and large indentation (easier to read). Tabs introduce confusion, and are best left out.
            3. Wrap lines so that they don't exceed 79 characters.
            4. Use blank lines to separate functions and classes, and larger blocks of code inside functions.
            5. When possible, put comments on a line of their own.
            6. Use docstrings.
            7. Use spaces around operators and after commas, but not directly inside bracketing 
                constructs: a = f(1, 2) + g(3, 4).
            8. Name your classes and functions consistently; the convention is to use UpperCamelCase for classes and 
                lowercase_with_underscores for functions and methods. Always use self as the name for the first method 
                argument (see A First Look at Classes for more on classes and methods).
            9. Don't use fancy encodings if your code is meant to be used in international environments. 
                Python's default, UTF-8, or even plain ASCII work best in any case.
            10. Likewise, don't use non-ASCII characters in identifiers if there is only the slightest chance people 
                speaking a different language will read or maintain the code.
        </p>
        </pre>
    </main>
</body>