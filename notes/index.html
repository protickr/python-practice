<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Notes</title>
    <style type="text/css">
        * {
            box-sizing: border-box;
            margin: 0;
        }

        main {
            width: 900px;
            margin: 0 auto;
        }

    </style>
</head>
<body>
    <main>
        <pre>
        <h2>Fundamentals: installation, execution, variables, data types</h2>
        <p>
            Installation and basic script execution
            1. install python and set environment variables so that python is recognized as a command 

            2. check version in terminal by, 
                python --version 

            3. create a file with extension .py e.g., main.py
            4. execute a python script from terminal by 
                python path_to_python_script.py

            * take input from console 
                x =  input('enter a number')
                input method always returns string 

            * print() 
                1. print() can take multiple arguments separated by comma 
                2. print() takes a keyword argument 'sep' to add separation between strings 
                3. print("%2f", 10.5)

                
            Variables
            variable is an identifier to a location in the memory, it is a container that hold a value 
            e.g., here 'message' is a variable which stores the value 'hello world' 
                message = 'hello world'
                print(message)

            * Variable naming convention 
                1. should be lowercase, in case of multiple words in a variable, all words should be 
                    linked by underscores e.g., multiple_word_variable = 10
                2. should not start with a number or special symbol or hyphen
                3. ALL_CAPS for constants 
                4. PascalCase for class names 


            Data Types
                1. integer, number with no decimal point, whole number
                2. float, number with a decimal point, decimal number
                3. string, string object. 
                4. booleans, True, False
                5. Set 
                6. Dictionary
                7. complex number
                8. null value, None

                python is dynamically typed meaning, the type of value determines the type of a variable


                * integer &lt;class 'int'&gt;
                    num = 10
                    
                * float &lt;class 'float'&gt;
                    num = 10.6

                * complex number 
                    In python, you can put 'j' or 'J' after a number to make it imaginary, so you can write complex 
                    literals easily:
                        1. z = 2 + 3j
                        2. z =  complex(2,3)
                         z.real == 2.0
                         z.imag == 3.0
                        
                * type casting / conversion 
                    num_1 = '10'
                    num_2 = '10.5'
                    
                    * string to int, float
                        print(int(num_1), float(num_2))     # 10 10.5
        </p>

        <h2>Strings</h2>
        <p>
            string is an sequence of characters which is stored as String object in python 

            string can be created by using double or single quotes, 
                message = 'this is a string'
                message = "This is a string"

            multi line string: 
                multi line string can be created by using 3 double or single quotes, 
                retains white space and formatting as created
                
                    message = '''hello 
                    world!'''
                    print(message)
                    
                    output: 
                    hello 
                    world!

            escape character 
                \ (back slash) is used to escape the character that follows it in a string so that it does not 
                have a special meaning 
                e.g., 
                    'a string with escape character it\'s'

            string methods: 
                message = "Hello world!"

                * lower case
                    message.lower()         # hello world!

                * upper case 
                    message.upper()         # HELLO WORLD!

                * count number of occurrence of a substring in a string 
                    message.count("world")   # 1
                    message.count("o")       # 2
                    message.count("t")       # 0
                

                * find starting index of a substring in a string 
                    only returns the first match 
                    message.find("world")    # 6
                    message.find('universe') # -1, if no match found

                * replace parts of a string with another string 
                    does not mutate the original string; returns a new string 
                    message.replace("world", "universe")     # Hello universe!

                * strip() characters at start and end of a string 
                    'this is a string'.strip()
                    if no argument is passed it strips empty whitespace and \n from start and end of a string
                    
                * string.islower() # True or False
                * string.isupper() # True or False

                * string concatenation 
                    greetings = "Hey"
                    name = "John"

                    * with (+) operator
                        message = "Hello " + "world!"
                        print(message)      # Hello world!

                    * with str.format() method / formatted string
                        message = '{}, {}. Welcome! '.format(greetings, name)
                        print(message)      # Hey, John. Welcome! 

                    * with f-string (template literals in JS)
                        message = f'{greetings}, {name}. Welcome!'
                        print(message)      # Hey, John. Welcome!


            * String formatting 
                1. string concatenation using + operator 
                2. string.format() method

                    name = 'Protick'
                    age = 28 

                    * placeholder wihtout index 
                        txt = 'I am {} my age is {}'.format(name, age)
                        print(txt)      # I am Protick my age is 28

                    * placeholder with index 
                        txt = ' I am {1} my age is {0}'.format(age, name)
                        print(txt)      # I am Protick my age is 28

                        element = '&lt;{0}> {1} &lt;/{0}>'.format('p', 'paragraph text')
                        print(element)  # &lt;p> paragraph text &lt;/p>
                        
                    * with dictionary
                        person = { 'name': 'Protick', 'age': 28 }
                        txt = 'I am {0[name]} my age is {1[age]}'.format(person, person)

                        or, 
                        txt = 'I am {0[name]} my age is {0[age]}'.format(person)
                        print(txt)      # I am Protick my age is 28

                    * with list
                        info = ['Protick', 28]
                        txt = 'I am {0[0]} my age is {0[1]}'.format(info)
                        print(txt)      # I am Protick my age is 28

                    * with object attributes 
                        class Person():
                            def __init__(self, name, age):
                                self.name = name
                                self.age = age 

                        p1 = Person('Protick', 28)
                        txt = 'I am {0.name} my age is {0.age}'.format(p1)
                        print(txt)      # I am Protick my age is 28

                    * with keyword argument 
                        txt = 'I am {name} my age is {age}'.format(name='Protick', age=28)
                        print(txt)      # I am Protick my age is 28

                        * dictionary unpacking to generate keyword arguments 
                            person = {'name': 'Protick', 'age': 28}
                            txt = 'I am {name} my age is {age}'.format(**person)
                            print(txt)      # I am Protick my age is 28

                    * number formatting 
                        1. add padding to number in a placeholder   
                            txt = '{0:02}'.format(8)
                            print(txt)      # '08'
                            
                        2. digits after decimal point of a float 
                            txt = '{0:.4f}'.format(3.141592)
                            print(txt)      # 3.1416

                            * also performs approximation

                        3. add comma separator and digits after decimal point to a number 
                            txt = '{0:,.2f}'.format(10000000)
                            print(txt)      # 10,000,000.00
                            

                    * data formatting 
                        with a date object 
                            from datetime import datetime
                            a = datetime(2022, 1, 11)
                            birthday = '{0:%B %d, %Y}'.format(a)
                            print(birthday)     # January 11, 2022
                    
                    *** There must not be any whitespace between placeholder curly braces and the
                        formatting string 
                            e.g., 
                                '{ 0:02 }'.format(7) ❌
                            right form would be, 
                                '{0:02}'.format(7) ✔

                
                3. f'string 
                    * with variable 
                        first_name = 'Protick'
                        last_name = 'Roy'
                        txt = f'My name is {first_name} {last_name}'
                        print(txt)          # My name is Protick Roy

                    * with dictionary
                        person = {'name': 'Jenn', 'age': 23}
                        txt = f'My name is {person["name"]} and I am {person["age"]} years old'
                        print(txt)          # My name is Jenn and I am 23 years old


                    * you can also perform calculation within f'string's placeholder 
                        txt = f'4 times 11 is  {4*11}'
                        print(txt)          # 4 times 11 is  44


                    * number padding 
                        num = 3 
                        txt = f'{num:02}'
                        print(txt)          # 03

                    # floating point formatting 
                        pi = 3.141592
                        txt = f'PI to 4 decimal place with approximation, {pi:.4f}'
                        print(txt)          # PI to 4 decimal place with approximation, 3.1416

                    # date formatting 
                        from datetime import datetime
                        a = datetime(2022, 1, 11)
                        date_str = f'the day was, {a:%B %d, %Y}'
                        print(date_str)     # the day was, January 11, 2022
        </p>

        <h2>Built in functions</h2>
        <p> 
            functions that can be used directly without importing anything or using any namespace
            * dir()
                dir(variable)
                returns all methods and attributes that we have access to when using a variable
    
            * help()
                help(str)
                returns doc string of a class           
                
            
            * absolute value - abs() 
                abs(-15)               # 15

            * round to nearest int or float 
                * nearest int 
                    round(10.6)        # 11
                 
                * round to nearest float 
                    round to 1 decimal place
                    round(10.65, 1)    # 10.7

            * built in function to retrieve object's memory location - id() 
                num = 10
                print(id(num))  # 2960035414544

            * min(), max(), sum() 
                returns minium, maximum and sum of a sequence 
                    nums = [1, 2, 4, 3, 5]
                    * min(nums)   # 1
                    * max(nums)   # 5
                    * sum(nums)   # 15
            
            * pow(base, exponent)
                pow(2, 10)  # 1024 
            
            * to help understand the MRO of a subclass we can use help() function 
                help(Subclass)

            * isinstance(obj, Class)

            * issubclass(ChildClass, ParentClass)

            * all these are available, 
                # hasattr(obj, key)
                # getattr(obj, key)
                # setattr(obj, key, value)
                # delattr(obj, key)

                # isinstance()
                # issubclass()

                # type(Obj|Class)
                # help(Obj|Class)
                # vars(obj|Class)
                # dir(obj|Class)
        </p>

        <h2>Operators</h2>
        <p>
            * arithmetic operators
                num_1 = 10
                num_2 = 3

                * parenthesis
                    (num_1 * 2) * num_2     # 60

                * exponentiation
                    num_1 ** num_2          
                    # 10 to the power of 3 = 10 * 10 * 10 == 1000

                * multiplication 
                    num_1 * num_2           # 30

                * division 
                    num_1 / num_2   
                    # in python 3,      10 / 3 == 3.3333333333333335
                    # in python 2,      10 / 3 == 3

                * floor division 
                    num_1 // num_2          # 10 // 3 == 3

                * remainder operator
                    num_1 % num_2           # 10 % 3 == 1 

                * addition 
                    num_1 + num_2           # 10 + 3 == 13

                * subtraction 
                    num_1 - num_2           # 10 - 3 == 7

                * arithmetic operator precedence order 
                    Parenthesis Exponentiation Multiplication Division Addition Subtraction
                    PEMDAS



            * Comparison operator 
                ==, !=, >, &lt;, >=, &lt;=

                num_1 = 10
                num_2 = 3

                * equal 
                     num_1 == num_2     # 10 == 3 ? False 

                * not equal 
                    num_1 != num_2      # 10 != 3 ? True

                * greater than 
                    num_1 > num_2       # 10 > 3 ? True

                * less than 
                    num_1 &lt; num_2       # 10 &lt; 3 ? False

                * greater than or equal 
                    num_1 >= num_2      # 10 >= 3 ? True

                * less than or equal 
                     num_1 &lt;= num_2     # 10 &lt;= 3 ? False



            * assignment and compound assignment operator 

                * (assignment ) operator 
                    num = 10

                * compound assignment operators 
                    num += 1
                    num = num + 1 == 11

                    num **= 2
                    num = num ** 2 
                    num = 10 ** 2
                    num = 100

                    * similarly,  
                        -=, *=, /=, //=, %=, **= 

            
            * logical operators 
                and, or, not


            * membership operator 'in'
                checks if a value is present in an object, iterables
                e.g., 
                    nums = [ 1, 2, 3, 4]
                    val = 3
                    if val in nums: 
                        print(f'{val} is present in the list')

            * identity operator 'is'
                checks if two variable references to the same object in memory
                    a = [1, 2, 3]
                    b = [1, 2, 3]
                
                    1. 
                        print(a is b) False 
                        print( a == b) True
            
                    2.
                        a = b 
                        print( a is b)
                        True

            * bit-wise operator 
                &, |, ^, ~ &lt;&lt;, >>
                Left and right shift are zero fills 
                Right shift is signed

            * Operator precedence 
                ()
                **      [Associativity: right to left]
                +var 
                -var 
                ~var 
                * 
                / 
                // 
                % 
                + 
                - 
                &lt;&lt; 
                >> 
                & 
                ^ 
                | 
                Comparison 
                Identity 
                Membership 
                not 
                and 
                or

                Assignment "=" and comparison operator does not have associativity 
                Rest of them have associativity of left to right 
        </p>

        <h2>Conditionals, True and False values, Match statement </h2>
        <p>
            * Boolean values - '&lt;class 'bool'&gt;'
                1. True 
                2. False

            * False Values 
                1. False
                2. None
                3. Zero of any numeric type i.e., int, float, 
                4. empty sequence such as empty tuples(), lists [], strings ""
                5. empty mappings such as dictionaries {}, sets {}
                
            * True values 
                except for False values everything else is True

                
            * if elif else
                if condition_1: 
                    'condition 1 is true'
                elif condition_2:
                    'condition_1 is false and condition_2 is true' 
                else: 
                    'condition_1 and condition_2 are false'

            * ternary operator 
                statement a if True else b


            * Match statement 
                A match statement takes an expression and compares its value to successive patterns given as one 
                or more case blocks Only the first pattern that matches gets executed and it can also extract 
                components (sequence elements or object attributes) from the value into variables.

                    def http_error(status):
                        match status:
                            case 400:
                                return "Bad request"
                            case 404:
                                return "Not found"
                            case 418:
                                return "I'm a teapot"
                            case _:
                                return "Something's wrong with the internet"

                * _ acts as a wildcard and never fails to match default case.
                    If no case matches, none of the branches is executed.

                * You can combine several literals in a single pattern using | (“or”):
                    case 401 | 403 | 404:
                        return "Not allowed"

                * Patterns can look like unpacking assignments, and can be used to bind variables:
                    # point is an (x, y) tuple
                    match point:
                        case (0, 0):
                            print("Origin")
                        case (0, y):
                            print(f"Y={y}")
                        case (x, 0):
                            print(f"X={x}")
                        case (x, y):
                            print(f"X={x}, Y={y}")
                        case _:
                            raise ValueError("Not a point")

                    1. The first pattern has two literals, and can be thought of as an extension of the literal 
                        pattern shown above. 

                    2. But the next two patterns combine a literal and a variable, and the variable binds a value 
                        from the subject (point).

                    3. captures two values, which makes it conceptually similar to the 
                        unpacking assignment (x, y) = point.

                * We can add an if clause to a pattern, known as a “guard”. If the guard is false, match goes 
                    on to try the next case block. Note that value capture happens before the guard is evaluated:

                    match point:
                        case Point(x, y) if x == y:
                            print(f"Y=X at {x}")
                        case Point(x, y):
                            print(f"Not on the diagonal")


                * Several other key features of this statement:
                    An important exception is that they don't match iterators or strings.
                    
                    * Sequence patterns support extended unpacking: [x, y, *rest] and (x, y, *rest) 
                        work similar to unpacking assignments. The name after * may also be _, so (x, y, *_) 
                        matches a sequence of at least two items without binding the remaining items.
                    
                    * Mapping patterns: {"bandwidth": b, "latency": l} captures the "bandwidth" and "latency" 
                        values from a dictionary. Unlike sequence patterns, extra keys are ignored. An unpacking 
                        like **rest is also supported. (But **_ would be redundant, so it is not allowed.)
                    
                    * Most literals are compared by equality, however the singletons True, False 
                        and None are compared by identity.
                    
                    * Patterns may use named constants. These must be dotted names to prevent them 
                        from being interpreted as capture variable:
                    
                            from enum import Enum
                            class Color(Enum):
                                RED = 'red'
                                GREEN = 'green'
                                BLUE = 'blue'
                            
                            color = Color(input("Enter your choice of 'red', 'blue' or 'green': "))
                            
                            match color:
                                case Color.RED:
                                    print("I see red!")
                                case Color.GREEN:
                                    print("Grass is green")
                                case Color.BLUE:
                                    print("I'm feeling the blues :(")

        </p>

        <h2>Error Handling, Duck Typing, LBYL, EAFP</h2>
        <p>
            * Error handling 
                try: 
                    # statements that might produce exception
                    # or raise exception manually by 
                        raise ExceptionType

                catch NameError as ne: 
                    # notify user of the error that occurred 

                catch Exception as e:
                    # exception of type Exception is caught 
                    # do what need to be done 

                else: 
                    # this block executes if there was no error or no catch block was executed 

                finally: 
                    # this block executes always 

                * else and finally block are optional 
                * you can use more that one catch block and different Exception / Error class in different blocks.


            * Duck Typing 
                it is a pythonic (coding style) approach. what it means by duck typing is you assume if an object
                walks like a duck and quacks like a duck then it is a duck. 
                we do not care about the object's type we are only interested in its functionality.
                goal of this approach is to create generalized code construct so that the construct can operate 
                on as much much object as it can, regardless of object type. 
                keeps code duplication to minimum. 
                
                One major drawback of this approach is that over generalization might lead to more exception 
                than anticipated. 

            * LBYL
                To veer away from exceptions we often resort to a certain coding style where we use guard clauses
                to prevent that exception from happening. This approach in generally followed in many other 
                programming languages and we call it 'Look Before You Leap' or LBYL in short.
                    e.g., 
                        if hasattr(obj, 'attribute_name'):
                            if callable(obj.attribute_name):
                                obj.attribute_name()

            * EAFP
                But python community recommends another way to deal with the same problem called 
                'Easier to Ask for Forgiveness than Permission' or EAFP. In this approach we use 
                try catch block to perform an action and catch the error and handle it as needed.
                    e.g., 
                        try:
                            obj.attribute_name()
                        catch Exception as e: 
                            print(e)

                why EAFP is pythonic and LBYL is not ?
                    1. EAFP helps reduce the execution time as python is a bit slow compared to other compiled 
                        languages. Checking with multiple guard clauses is more heavy on the processor unit than 
                        catching exception with one or more catch blocks. 

                    2. Race condition 
                        LBYL might lead to race condition
                        always use try catch while accessing resources rather than conditionals.
        </p>

        <h2>Python Builtin Data Structures</h2>
        <p>
            <strong>Lists</strong>  
            list is a collection of elements. list is not actually array because list can have heterogenous 
            data as list element. takes a lot more space than arrays 
            array.array and numpy.ndarray are arrays. 

            lists can have different types of data as element. 
                1. lists can have lists as elements
                2. list can have dict as elements 
                3. list can have all of the above at the same list at the same time. 
                4. list retains order 
                5. lists are mutable

            declaring a list 
                1. students = []
                2. students = list()
                type(students)  # &lt;class 'list'&gt;
                
                
            * list methods 
                courses = ['Bangla', 'English', 'Math']
            
                * length of a list
                    len(courses)        # 3
                    
                * access list element by index
                    courses[1]          # English
                    
                * access list item by negative index 
                    negative index starts from -1 from the end of a list
                    courses[-1]         # Math
                    
                * update list element by index 
                    courses[-1] = 'Mathematics'
                    print(courses)      # ['Bangla', 'English', 'Mathematics']
                    
                * list slicing / new list from a list by start index (inclusive) and end index ( not inclusive ) 
                    new_list = courses[ 1 : 2 ]
                    print(new_list)     # ['English']
                    
                    * omitting start index will default to 0 
                        courses[:2]         # ['Bangla', 'English']
                        
                    * omitting end index will return all elements including the last element of a list
                        courses[0:]         # ['Bangla', 'English', 'Math']
                        
                    
                * list.append(value)
                    append new element at the end of a list 
                        courses.append('History')
                        print(courses)      # ['Bangla', 'English', 'Math', 'History']
                        
                * list.insert(index, value)
                    append element at the specified index and shifts the current element and the consecutive 
                    elements to the right 
                    the 'value' can also be a list and in that case it will be placed in the list as an element
                        courses.insert(1, 'History')
                        print(courses)      # ['Bangla', 'History', 'English', 'Math']

                    * If index is out of range then inserts value at the last of the list. 
                        
                    
                * list.extend([new, list])
                    unpacks the extend's argument into separate elements and append them to the list 
                        new_courses = ['History', 'Physics']
                        courses.extend(new_courses)
                        print(courses)      # ['Bangla', 'English', 'Math', 'History', 'Physics']
                        
                * list.pop(index)
                    * pops last value from a list if index argument is not passed
                        popped_value = courses.pop()
                        print(popped_value)     # Math

                    * pop value from a list by index
                        print(courses.pop(-2))  # English
                        print(courses)          # ['Bangla', 'Math']
                    
                * list.remove(value)
                    removes a value from a list 
                        res = courses.remove('English')
                        print(res)      # None
                        print(courses)  # ['Bangla', 'Math']
                    
                * list.reverse()
                    mutates the list and Reverse the elements of the list in place. 
                        courses.reverse() 
                        print(courses)  # ['Math', 'English', 'Bangla']
                        
                * list.sort() 
                    sorts in alphabetical or numerical order by default, sorts in place 
                    meaning it mutates the original list
                        courses.sort()
                        print(courses)  # ['Bangla', 'English', 'Math']
                
                * list.copy()
                    Return a shallow copy of the list meaning nested elements will not be copied. 
                    Equivalent to courses[:]
                        courses_copy = courses.copy()    
                        print(id(courses), courses)           # 2373837887232 ['Bangla', 'English', 'Math']
                        print(id(courses_copy), courses_copy)   # 2373837985600 ['Bangla', 'English', 'Math']
                        
                * list.count()
                    returns the number of entries of an element in a list or 0 if not present
                    courses.count("Bangla")     # 1
                    courses.count("Biology")    # 0
                    
                * list.index()
                    returns the index of an element in a list or exception if not found
                        courses.index("English") # 1
                        courses.index("Biology") # ValueError: 'Biology' is not in list
                    
                * del list[index]
                    deletes item from a list at provided index
                        del courses[1]
                        print(courses)  # ['Bangla', 'Math']
                        
                * list.clear()
                    deletes all elements from an array
                        courses.clear()
                        print(courses)  # []
                        
                * list to string 
                    courses_str = ', '.join(courses)
                    print(courses_str)  # Bangla, English, Math
                    
                * string to list 
                    courses_from_str = courses_str.split(', ')
                    print(courses_from_str)     # ['Bangla', 'English', 'Math']




            <strong>Tuples</strong>
            A tuple consists of a number of values separated by commas
            Though tuples may seem similar to lists, they are often used in different situations 
            and for different purposes. Tuples are immutable, and usually contain a heterogeneous 
            sequence of elements that are accessed via unpacking or indexing or even by attribute in 
            the case of named-tuples. 
            Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list.
        
            declaring a tuple 
                1. months = ()
                2. months = tuple()
                type(months)                    # &lt;class 'tuple'&gt;


            * single element tuple 
                new_tuple = (123,)
                print(new_tuple)                # (123,)

            * empty tuple 
                months = ()
                print(months, type(months))     # () &lt;class 'tuple'&gt;

            * packing 
                t = 12345, 54321, 'hello!'
                print(t, type(t))               # (12345, 54321, 'hello!') &lt;class 'tuple'&gt;

            * unpacking 
                t = 12345, 54321, 'hello!'
                a, b, c = t
                print(a, b, c)  # 12345 54321 hello!


            new_tuple = (12345, 54321, 'hello!')

            * retrieving tuple elements by index
                print(new_tuple[-1])    # hello!

            * assignment operation using tuple index throws error 

            * tuple methods 
                * tuple.count(value)
                    returns number of times an element is present in the tuple
                        print(new_tuple.count("hello!"))    # 1

                * tuple.index()
                    returns index of an element in a tuple or exception
                    print(new_tuple.index('hello!'))    # 2
                    print(new_tuple.index('welcome'))   # ValueError: tuple.index(x): x not in tuple

                * two tuples can be concatenated by + operation 
                    extended_tuple = new_tuple + (1, 2, 3)
                    print(extended_tuple)   # (12345, 54321, 'hello!', 1, 2, 3)

                * tuple initialization 
                    nt = ('hi', ) * 5
                    print(nt)   # ('hi', 'hi', 'hi', 'hi', 'hi')
                    interesting but I do not know where to use this technique



                * namedtuple             
                    * tuples
                        color = (55, 155, 255)
                        print(color[0]) # 55
                        
                    * named tuple 
                        from collections import namedtuple
                        Color = namedtuple('Color', ['red', 'green', 'blue'])
                        color = Color(55, 155, 255)
                        print(color)        # Color(red=55, green=155, blue=255)

                        * The first parameter to the namedtuple() constructor sets the name of the generated class:
                            here the name Color at the left of the assignment is just a reference to the returned 
                            class from the namedtuple() constructor 

                    * accessing element of a namedtuple 
                        1. by index 
                            print(color[0])     # 55

                        2. by attribute
                            print(color.red)    # 55


            <strong>Sets</strong>
            Python also includes a data type for sets. A set is an unordered collection 
            with no duplicate elements. Basic uses include membership testing and eliminating 
            duplicate entries.

            Set objects also support mathematical operations like union, intersection, difference, 
            and symmetric difference.

            Curly braces or the set() function can be used to create sets. 
            Note: to create an empty set you have to use set(), not {}

            sets are mutable but an immutable set can be generated by using frozenset()
            sets are optimized to use membership operator( in )


            declaring a set 
                1.  species = { 'Homo habilis', 'Homo rudolfensis', 'Homo erectus', 'Homo antecessor' }
                    species = {} will create an empty dictionary not a set.                     
                2.  species = set()
                type(species)   # &lt;class 'set'&gt;

                * as sets are unordered/un-indexed we can not access it by index 

            * set methods
                new_set = { 1, 2, 3, 4, 5, 3, 4, 6 }
                print(new_set)      # {1, 2, 3, 4, 5, 6}

                * set.add(new_element)
                    adds a new_element to the set
                        new_set.add(7)
                        print(new_set)      # {1, 2, 3, 4, 5, 6, 7}

                * set.remove(element)
                    removes element if exists or else throws an Exception
                        new_set.remove(6)
                        print(new_set)      # {1, 2, 3, 4, 5}
                        new_set.remove(7)
                        KeyError: 7

                * set.discard(element)
                    removes element from a set if it exists or does nothing if not. 
                        new_set.discard(7)
                        print(new_set)      # {1, 2, 3, 4, 5, 6}

                * set.pop()
                    pops and returns random element from the set
                        x = new_set.pop()
                        print(x, new_set)   # 1 {2, 3, 4, 5, 6}

                * set.clear()
                    removes all elements from a set and returns NoneType object, mutates the set
                        new_set.clear()
                        
                * del set()
                    deletes set from context
                        del new_set

                * create set from a list 
                    set_from_list = set([1, 2, 3, 4, 5, 1, 2])
                    print(set_from_list)    # {1, 2, 3, 4, 5}

                * create list from a set
                    list_from_set = list(set_from_list)
                    print(list_from_set)
                    [1, 2, 3, 4, 5]


                * set operations
                    returns a new result set; does not modify operands

                    a = { 1, 2, 3 }
                    b = { 3, 4, 5 }

                    * union
                        print(a.union(b))           # {1, 2, 3, 4, 5}

                    * intersection
                        print( a.intersection(b))   # {3}

                    * in a but not in b ( difference )
                        print( a.difference(b))     # {1, 2}

                    * symbolic difference 
                        print(a.symmetric_difference(b))    # {1, 2, 4, 5}

                    * a.isdisjoint(b), a.issubset(b), a.issuperset(b) methods are also available




            <strong>Dictionaries</strong>
            Dictionary is an unordered collection of key value pairs where value can be anything and 
            dictionaries are indexed by keys, which can be any immutable type; 
            strings and numbers can always be keys. 
            Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple 
            contains any mutable object either directly or indirectly, it cannot be used as a key. 
            You can't use lists as keys, since lists can be modified in place using index assignments, 
            slice assignments, or methods like append() and extend().
            It is best to think of a dictionary as a set of key: value pairs, 
            with the requirement that the keys are unique (within one dictionary).

            * declaring a dictionary 
                1. student = {}
                2. student = dict()
                3. The dict() constructor builds dictionaries directly from sequences of key-value pairs

                print(type(student))    # &lt;class 'dict'&gt;


            john = { 'name': 'John', 'age': 28, 'country': 'Bangladesh' }
            
            * access dictionary entries
                * dict_obj[key]
                    returns value against a key or throws a KeyError if key does not exist
                        print(john['name'])     # John

                * inserting or updating a new entry 
                    john['age'] = 27
                    print(john)     # {'name': 'John', 'age': 27, 'country': 'Bangladesh'}
                    
                * insert value against a key
                    john['language'] = 'Bangla'
                    print(john)     # {'name': 'John', 'age': 28, 'country': 'Bangladesh', 'language': 'Bangla'}




            * dictionary methods
                * dict.get(key, default_value)
                    returns None or default value if key does not exist or the value at the key if it exists
                        *   print(john.get('name'))         # John
                            print(john.get('language'))     # None
                            
                        *   print(john.get('language', 'Bangla')) # Bangla

                * dict.update({})
                    insert and update entries of a dictionary 
                    inserts new key: value pair if key does not exist in dictionary or update if key exists 
                        john.update({'language': 'Bangla', 'country': 'Heaven'})
                        print(john)     # {'name': 'John', 'age': 28, 'country': 'Heaven', 'language': 'Bangla'}

                * dict.pop(key)
                    pops and returns value from a dictionary against the provided key or 
                    throws KeyError if key does not exist
                        x = john.pop('age')
                        print(x)    # 28

                        x = john.pop('language')
                            KeyError: 'language'

                * dict.keys()
                    returns a list of keys 
                        keys = john.keys()
                        print(keys)     # dict_keys(['name', 'age', 'country'])

                * dict.values()
                    returns a list of values 
                        values = john.values()
                        print(values)   # dict_values(['John', 28, 'Bangladesh'])

                * dict.items()
                    returns a list of tuples (key, value) 
                        items = john.items()
                        print(items)    # dict_items([('name', 'John'), ('age', 28), ('country', 'Bangladesh')])

                * dict.popitem()
                    pops and returns last key value as a tuple: (key, value) 
                        last = john.popitem()
                        print(last)     # ('country', 'Bangladesh')

                * dict.clear()
                    clears dictionary
                        d = john.clear()
                        print(d, john)  # None {}

                * len(dict_obj)
                    returns length of a dictionary object 
                        len(john)       # 3

                * del dict_obj[key]
                    deletes key: value from a dictionary 
                        del john['age']
                        print(john)     # {'name': 'John', 'country': 'Bangladesh'}
        </p>

        <h2>Slicing, Sorting, Comprehension</h2>
        <p>
            <strong>Slicing</strong>
            extract certain elements from lists and strings 
            
            * Lists and Strings 
                nl = [0,   1,   2,  3,  4,  5,  6,  7,  8,  9]
                      0,   1,   2,  3,  4,  5,  6,  7,  8,  9 -> positive index
                    -10,  -9,  -8, -7, -6, -5, -4, -3, -2, -1 -> negative index
            
                * retrieving same element of the list using positive and negative index 
                    print(nl[0], nl[-10])   # 0 0

                * print(nl[1:-1:2])         # [1, 3, 5, 7]
                    nl[start:end:step]
                        start from index 1 end at index -1 (not inclusive) with step size of 2 meaning 
                        take every second element of the list extracted by start:end == 1:-1
                    

                * print(nl[3::])            # [3, 4, 5, 6, 7, 8, 9]
                    start from index 3 and take all elements including the last 
                    

                * print(nl[:9])             # [0, 1, 2, 3, 4, 5, 6, 7, 8]
                    start index is not given so start from 0 and upto index 9 (not inclusive)
                    

                * we can also use negative step size. In that case list element extraction will start from the 
                    opposite of the default direction (which is left to right)

                        print(nl[-1:1:-1])  # [9, 8, 7, 6, 5, 4, 3, 2]

                        print(nl[1:9:-1])   # []
                            you can not just go to index 9 from index 1 at reverse order 

                * reversing a list 
                    print(nl[::-1])         # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

                * slicing also applies to strings same as lists
            
            <strong>Comprehension</strong>
            * List 
                nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]
                
                1.  my_list = [ item for item in nums ]
                    print(nums, my_list)        # [1, 2, 3, 4, 5, 6, 7, 8, 9]    [1, 2, 3, 4, 5, 6, 7, 8, 9]

                2.  my_list = [ n * n for n in nums ]
                    print(my_list)              # [1, 4, 9, 16, 25, 36, 49, 64, 81]
                       
                    * lambda function equivalent of the last list comprehension
                        my_list = list(map(lambda x: x * x, nums))
                        print(my_list)          # [1, 4, 9, 16, 25, 36, 49, 64, 81]

                3.  my_list = [ n for n in nums if n % 2 == 0 ]
                    print(my_list)              # [2, 4, 6, 8]

                4.  nested for loops in list comprehension 
                        my_list = [(letter, num) for letter in 'abc' for num in range(2)]
                        print(my_list)          # [('a', 0), ('a', 1), ('b', 0), ('b', 1), ('c', 0), ('c', 1)]

                
            * Dictionary
                    names = [ 'Peter', 'Bruce', 'Clerk', 'Jhony']
                    heroes = [ 'Spiderman', 'Batman', 'Superman', 'Jack Sparrow' ]

                    my_dict = { name: hero for name, hero in zip(names, heroes) if name != 'Peter'}
                    print(my_dict)      # {'Bruce': 'Batman', 'Clerk': 'Superman', 'Jhony': 'Jack Sparrow'}


            * Set
                nums = [1, 2, 3, 4, 5, 6, 3, 4, 5, 7, 8, 9]
                my_set = { n for n in nums }
                print(my_set)           # {1, 2, 3, 4, 5, 6, 7, 8, 9}

            
            * generator expression 
                nums = [1, 2, 3, 4]
                my_gen = (n * n for n in nums)
                print(type(my_gen))         # &lt;class 'generator'&gt;

                    1. convert generator to list 
                        print( list(my_gen))        # [1, 4, 9, 16]

                    2. loop over a generator
                        for n in my_gen: 
                            print(n)                # 1 4 9 16 each element on a new line
            

            * tuple 
                there is no syntax for tuple comprehension but you can do it with tuple() constructor 
                combined with generator expression 
                
                    my_tup = tuple(my_gen)
                    print(my_tup)       # (1, 4, 9, 16)


            <strong> Sorting </strong>
            Lists 
                li = [1, 2, 3, 4]

                1. using list.sort() 
                    li.sort()
                        sorts list in place mutating the original list 
                        returns None as return value 
                        sorts in ascending order by default 

                    li.sort(reverse=True)
                        sorts in descending order 

                2. using sorted() function 
                    nli = sorted(li) 
                        returns a new sorted list 
                        sorts in ascending order by default 

                    nli = sorted(li, reverse=True)
                        sorts in descending order 

                * sort() method is not available on any other sequence type objects other than lists 
                * tuples, sets and dictionaries can be sorted using sorted() method 

            Dictionary 
                1. sd = sorted(dict_obj)
                    sorts the dict_obj based on the keys and returns the sorted dictionary  


            * sorted also accepts a keyword argument 'key' which takes a function as a value 
                the value returned by that function will be used during sorting the sequence 
                
                li = [-6, -5, -4, 1, 2, 3]
                
                to sort li list based on absolute value of the elements we can pass builtin abs function as 
                key value 
                    nli = sorted(li, key=abs)

            Objects 
                1. sort using a custom sorter function 
                    class Employee():
                        def __init__(self, name, age):
                            self.name = name
                            self.age = age 
                
                    def sorter_func(emp):
                        return emp.age
                    
                    
                    e1 = Employee('Corey', 26)
                    e2 = Employee('Jonas', 24)
                    emps = [e1, e2]
                    
                    sorted_emps = sorted(emps, key=sorter_func)
                    print(sorted_emps[0].age, sorted_emps[1].age)   # 24 26
                    
                2. sort using builtin attrgetter function 

                    from operator import attrgetter 
                    sorted_emps = sorted(emps, key=attrgetter('age'))
                    print(sorted_emps[0].age, sorted_emps[1].age)   # 24 26
        </p>

        <h2>Loops</h2>
        <p>
            <strong>for</strong> 
                nums = [1 , 2, 3, 4, 5]
                * with sequence or collection data
                    for num in nums: 
                        print(num)  # 1 2 3 4 5 [each element on a new line]

                * with range(start, stop)
                    * range(stop) == range(0, stop)
                        1. returns an iterable which starts from start value (inclusive)  and 
                            stops at end value (not inclusive)
                        2. if single value is passed as an argument then start value becomes 0
                        
                    for i in range(1, 6):
                        print(i)    # 1 2 3 4 5 [each element on a new line]




            <strong>while</strong> 
                x = 0
                while x &lt; 10: 
                    print(x)
                    x += 1
                
                # 0 1 2 3 4 5 6 7 8 9 [each element on a new line]


                * infinite loop
                    x = 0
                    while True: 
                        x += 1
                        if x == 4: 
                            continue
                        if x == 5:
                            break
                        print(x)

                    # 1 2 3 [each element on a new line]
            


            <strong>else clause on loops </strong> 
                The else clause is executed if you exit a block normally, by hitting the loop 
                condition or falling off the bottom of a try block. 
                It is not executed if you break or return out of a block, or raise an exception. 
                It works for not only while and for loops, but also try blocks.

                You typically find it in places where normally you would exit a loop early, and running 
                off the end of the loop is an unexpected/unusual occasion. For example, if you're looping 
                through a list looking for a value:

                    values = [ 1, 2, 3, 4, 5, 6]
                    for value in values:
                        if value == 5:
                            print("Found it!")
                            break
                    else:
                        print("Nowhere to be found. :-(")
        </p>

        <h2>Function</h2>
        <p>
            def func():
                ''' Doc string '''
                print('Func function is called')
                return True
            
            1. The keyword def introduces a function definition. It must be followed by the function name and 
                the parenthesized list of formal parameters.
            2. The first statement of the function body can optionally be a string literal; 
                this string literal is the function's documentation string, or docstring
            3. The execution of a function introduces a new symbol table used for the local variables of the function. 
                More precisely, all variable assignments in a function store the value in the local symbol table
            
            * Scope chain 
                variable look up happens in the following order,  
                    1. local symbol table 
                    2. local symbol tables of enclosing functions 
                    3. global symbol table 
                    4. table of built-in names
                * LEGB Rule: Local, Enclosed, Global, Builtins

                Note 1:
                Thus, global variables and variables of enclosing functions cannot be directly 
                assigned a value within a function (unless, for global variables, named in a global statement, 
                or, for variables of enclosing functions, named in a nonlocal statement), 
                although they may be referenced (their value can be retrieved)

            * How Arguments (Actual Parameters) and Parameters (Formal Parameters)  are Stored 
                1. The actual parameters (arguments) to a function call are introduced in the local symbol table of the 
                    called function when it is called; thus, arguments are passed using call by value (where the value 
                    is always an object reference, not the value of the object).
                2. When a function calls another function, or calls itself recursively, a new local symbol table is 
                    created for that call.

            * Functions are objects 
                A function definition associates the function name with the function object in the current symbol table. 
                The interpreter recognizes the object pointed to by that name as a user-defined function. 
                Other names can also point to that same function object and can also be used to access the function
            
            * Return Value
                The return statement returns with a value from a function. 
                Even functions without a return statement do return a value, This value is called None 
                Falling off the end of a function also returns None.

            * How default argument values are stored
                Note 2: 
                The default values are evaluated at the point of function definition in the defining scope, so that
                def f(arg=i) says "make me a function f where the default value for arg is whatever i is right now". 
                At the time of defining the function, i=5.

                *** The default values are evaluated at the point of function definition 
                    in the defining scope, so that
                    i = 5
                    def f(arg=i):
                        print(arg)

                    i = 6
                    f()
                    will print 5

                *** Important warning: The default value is evaluated only once. This makes a difference when 
                    the default is a mutable object such as a list, dictionary, or instances of most classes. 
                    For example, the following function accumulates the arguments passed to it on subsequent calls:

                        def f(a, L=[]):
                            L.append(a)
                            return L
                        
                        print(f(1))
                        print(f(2))
                        print(f(3))

                        This will print
                        [1]
                        [1, 2]
                        [1, 2, 3]

                    because the default argument L points to a list object which is created at the time of function 
                    definition.

                    Note 3: 
                    when the function definition was executed and the execution result was stored in 
                    memory as a function object to which the name 'f' refers to. In that function object's local scope 
                    a variable was defined named 'L' which were assigned a value to a list object which is 
                    stored in somewhere else in the memory.

                    * To do not fall into this pitfall you can omit using mutable objects as 
                        default value to a parameter or you can do the following, 

                        def f(a, L=None):
                            if L is None:
                                L = []
                            L.append(a)
                            return L

            * Positional and Keyword arguments and optional parameter
                def func(pos_arg, kwarg_1='No value', kwarg_2=True):
                    print(pos_arg, kwarg_1, kwarg_2)
            
                func('Required Positional Argument',
                    kwarg_1='keyword argument for optional parameter kwarg_1')
    
                    this will print, 
                        Required Positional Argument keyword argument for optional parameter kwarg_1 True
                
                In this example,
                1. 'pos_arg' is a required positional parameter ( / formal argument) 
                2. 'kwarg_1' and 'kwarg_2' are optional parameters (/ formal arguments )
                3. when we are calling the function, 
                    the value passed at the first position is a positional argument and it is required
                    in the second position, we are passing a keyword argument 'kwarg_1' = 'value'
                    for the third, we did not pass any arguments and that is okay because it is optional. 

            * Rules for passing arguments 
                    1. all keyword arguments must come after all positional arguments from left to right 
                        or it will throw exception 

                    2. value to a positional parameter can also be passed with a keyword argument.
                        for the previous example, we can pass value to positional parameter 'pos_arg' by, 

                            func(pos_arg = 'Required Positional Argument') and it will work.

                    3. All the keyword arguments passed must match one of the arguments accepted by the function, 
                        and their order is not important. This also includes non-optional arguments.

                            func(kwarg_1 = 'keyword arg', pos_arg = 'pos arg')
                            output:  pos arg keyword arg True

                    4. No argument may receive a value more than once.
                        for the previous example, 
                            func('This is for required positional parameter', pos_arg = 'Required Positional Argument')

                            this function call will throw an error as we are passing two arguments for one parameter, 
                            1 positional argument and 1 keyword argument.
                            Error: func() got multiple values for argument 'pos_arg'


            * Special parameters
                Keyword parameters are also referred to as named parameters.
                By default, arguments may be passed to a Python function either by position or explicitly by keyword. 
                To restrict the way arguments can be passed,

                A function definition may look like:
                
                    def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
                        -----------    ----------     ----------
                            |             |                  |
                            |        Positional or keyword   |
                            |                                - Keyword only
                            -- Positional only

                where / and * are optional.

                1. Positional-only parameters are placed before a / (forward-slash).
                    If positional-only, the parameters' order matters, and the parameters cannot be passed by keyword.
                    If there is no / in the function definition, there are no positional-only parameters.

                2. Parameters following the / may be positional-or-keyword or keyword-only.
                
                3. To mark parameters as keyword-only, indicating the parameters must be passed by keyword argument, 
                    place an * in the arguments list just before the first keyword-only parameter.

                Perks:
                    the names of positional-only parameters can be used in **kwargs without ambiguity.

                As guidance:
                    1. Use positional-only if you want the name of the parameters to not be available to the user. 
                        This is useful when parameter names have no real meaning, if you want to enforce the order 
                        of the arguments when the function is called or if you need to take some positional parameters 
                        and arbitrary keywords.
                    2. Use keyword-only when names have meaning and the function definition is more understandable by 
                        being explicit with names or you want to prevent users relying on the position of the argument 
                        being passed.
                    3. For an API, use positional-only to prevent breaking API changes if the parameter's name is 
                        modified in the future.



            * Arbitrary Argument Lists - argument packing 
                1. Final formal parameter of the form *name which receives a tuple containing the positional 
                    arguments beyond the formal parameter list. 
                2. Final formal parameter of the form **name is present, it receives a dictionary containing 
                    all keyword arguments except for those corresponding to a formal parameter. 
                3. *name must occur before **name.

                def func(pos, kwarg='val', *args, **kwargs)
                    *args packs all the arguments which are passed beyond all the positional parameters in a tuple
                    **kwargs packs all the keyword arguments which are passed beyond all the keyword parameters 
                        in a dictionary

            
            * Unpacking Argument Lists
                1. unpacking a tuple and use elements as positional arguments
                    *(1, 10) is equivalent to 1, 10

                2. unpacking a dictionary and use key:value pair as keyword arguments 
                    **{'name': 'John', 'age': 25} is equivalent to  name='john', age=25


            * Lambda Expressions
                Small anonymous functions can be created with the lambda keyword. This function returns the sum of 
                its two arguments: lambda a, b: a+b.
                They are syntactically restricted to a single expression. Semantically, they are just syntactic 
                sugar for a normal function definition. 
                Like nested function definitions, lambda functions can reference variables from the containing scope:

                    def make_incrementor(n):
                        return lambda x: x + n
                    
                    f = make_incrementor(42)

            * Documentation Strings
                in short doc string describes an objects purpose, parameter, return value , exception type etc. 


            * Function Annotations
                Function annotations are completely optional metadata information about the types used 
                by user-defined functions

                    1. Parameter annotations are defined by a colon after the parameter name, followed by an 
                        expression evaluating to the value of the annotation. 

                    2. Return annotations are defined by a literal ->, followed by an expression, between the parameter 
                        list and the colon denoting the end of the def statement


            * skip body implementation by using pass keyword
                def func():
                    pass 

            * functions with positional arguments
                def hello_func(name, greetings):
                    print(f'{greetings } { name }!')

                hello_func('Protick', 'Hi')     # Hi Protick!

            * variable's scope chain, global and nonlocal statements

                x = 'global x'
                y = 'global y'
                def outer():
                    global x 
                    x = 'outer x'
                    y = 'outer y'
                
                    def inner():
                        # nonlocal x
                        nonlocal y 
                        y = 'inner y'
                        x = 'inner x'
                        print(x, y)
                    
                    inner()
                    print(x, y)
                
                outer()
                print(x, y)
                
                Variable scope 
                    where our variable can be accessed from within the program and what values those variables 
                    hold in different contexts 
                
                    1. Local Scope 
                        variable defined within a function body is called local variable and it is not 
                        accessible outside of the function body or from the global scope 

                    2. Global scope 
                        variable defined in the top level of a module and also variable declared with 
                        the global keyword. Global variable is available within the local scope of a function 
                        which is defined in that global scope

                    3. Local variable with the same name as a global variable will override the the global 
                        variable within that local scope. 

                    4. Though global variable can be accessed within a local scope, we can not reassign that 
                        global variable. To reassign a global variable from within a local scope we have to 
                        declare that global variable as 
                            global var 
                            var = 'new value'
                        
                    5. function parameter exists within the function's local scope 
                    
                    6. Builtins scope 
                        to see all the built-in variables are defined and available in the global scope, 
                            import builtins 
                            print(dir(builtins))

                    7. Enclosing scope 
                        inner function closes on all the variable's of outer scope and that outer scope can be 
                        local scope of another function 
                        that local scope of the outer function is called enclosed scope

                        you can access variables from enclosing scope like you accessed global variable within 
                        a local scope. But to assign or change value of a variable from enclosing scope you have
                        to declare that variable as, 
                            nonlocal var 
                            var = 'new value' 

                Note
                * global and nonlocal statement for a single variable name should not be combined 
                    for that variable name's scope chain 
                * do not override builtin names even if you are not prohibited by python.
                * Python look up for a variable in the scope chain by the LEGB rule. It first look up for a 
                    variable in Local scope then goes to Enclosing Scope then goes to Global scope and then 
                    goes to Builtins scope. If it finds a variable in a scope it stops looking up further in
                    the scope chain. If it does not find the variable in the whole scope chain it throws 
                    a NameError exception.
        </p>

        <h2>Class and OOP</h2>
        <p>
            * how to create a class in python ?
                class Employee:
                    num_of_emps = 0
                    raise_amount = 1.04

                    def __init__(self, first, last, pay):
                        self.first = first
                        self.last = last
                        self.pay = pay
                        self.email = first + last + "@gmail.com"

                        Employee.num_of_emps += 1

                    def fullname(self)->str:
                        return f'{self.first} {self.last}'

                    def apply_raise(self):
                        self.pay = int(self.pay * self.raise_amount)

                    @classmethod
                    def from_string(cls, emp_str):
                        first, last, pay = emp_str.split('-')
                        return cls(first, last, pay)

                    @classmethod 
                    def set_raise_amount(cls, amount):
                        cls.raise_amount = amount

                    @staticmethod 
                    def is_workday(day):
                        if (day.weekday() == 5 or day.weekday() == 6):
                            return False 
                        return True


                1. we can create an instance / object from a class by, 
                        emp_1 = Employee('Protick', 'Roy', 10000)
                        emp_2 = Employee('Test', 'User', 15000)
                    
                    * when we create instance of a class that instance is passed to the constructor __init__() 
                        method automatically as the first argument so we do not need to pass it explicitly.
                    * the __init__() method will run automatically upon creating the instance
                    * constructor method creates and initializes instance variables using the given parameter

                2. we can also create and assign value to new class attributes using the object reference 
                    emp_1.email = emp_1.first + emp_1.last + "@gmail.com"

                3. instance variables contain data that is unique to each instance, 
                    instance variables are also called attributes 

                4. Any instance method called using an object reference passes the object reference 
                    as the first argument to that method                 
                    each method inside a class will take the instance as first argument automatically
                            emp_1.fullname() 
                        passes the instance as first argument to the fullname() method automatically 

                5. we have to pass the instance/object reference as first argument specifically when 
                    calling an instance method by the Class name 
                        Employee.fullname(emp_1)


            * Class variables 
                * class variables are variables that are shared among all instance of a class 
                    e.g.,   num_of_emps, raise_amount

                * instance variables are unique to each instance
                    e.g.,   self.first, self.last, self.pay

                *  In apply_raise() method we used 'self.raise_amount' so that we can access the general 
                    raise_amount (class variable) and if need be then we can reassign the raise_amount 
                    using instance reference (then raise_amount becomes instance variable) and access that 
                    raise_amount (instance variable) specific to that instance without changing the code.

                * In Employee class's __init__() method we have 'Employee.num_of_emps += 1' which 
                    increments each time an instance is created using that class. Here we are using Class reference 
                    to access the class variable 'num_of_emps' because in no circumstance 
                    we want the 'num_of_emps' to become specific to any instance

                6. when we reassign a class variable with an instance reference then it overrides the class 
                    variable and creates a new instance variable with the same name as the class variable 
                    think of it as how global variable can be accessed in a local scope but re-assignment would 
                    lead to creating a new variable in that local scope with the same name as the global variable
                    
                7. we can access class variable through the class name itself or through any instance of the class, 
                    how ?
                    because of scope chain 
                    first it looks if the instance has an instance variable named raise_amount if not then 
                    it looks for the variable in the class from which it was created


            * class methods and static methods 

                * 3 types of methods 
                    regular methods, class methods, static methods

                1. regular method takes the instance reference as the first argument 

                2. class method takes the class reference as the first argument class method can be created by 
                    adding a decorator '@classmethod' to the top of a method definition inside a class 

                3. static method takes neither object nor class reference as first argument by default 
                    they are just regular functions which have some logical connection to the class itself 
                    static method can be declared with '@staticmethod' decorator
                    * static method does not depend on any class variable or instance variable 
                    * so if you need a method inside a class which does not need instance or class reference 
                        then declare that method as static method


                * in this example we have two class methods called 'from_str(cls, emp_str)' which works as an 
                    alternative constructor it takes a string and creates a new Employee object and returns it. 
                    Also the class reference is passed to it automatically as the first argument and 
                    'set_raise_amount(cls, amount)' takes an amount as an argument set the class variable raise_amount

                        emp_str_1 = 'John-Doe-20000'
                        emp_3 = Employee.from_string(emp_str_1)
                    
                    * you can also call class methods with instance reference but that does not make sense and 
                        it is rarely used 
                            emp_1.set_raise_amount(1.01)
                        this will change the class variable raise_amount same as invoking class method with 
                        the class name did

                * in this example we have a static method called 'is_workday(day)'
                    which takes a date object as argument and it returns a day is weekday or not 
                    Also it does not take any reference of instance or class as first arguments like 
                    instance method and class method did. 
                    we can invoke a class method using class or instance reference either way does not make 
                    any difference 

                        import datetime
                        my_date = datetime.date(2016, 7, 10)
                        Employee.is_workday(my_date)


            * Class inheritance 

                class Employee: 
                    raise_amount = 1.04
            
                    def __init__(self, first, last, pay):
                        self.first = first
                        self.last = last
                        self.pay = pay
                        self.email = f'{first}.{last}@email.com'
                
                    def fullname(self)->str:
                        return f'{self.first} {self.last}'
                
                    def apply_raise(self):
                        self.pay = int(self.pay * self.raise_amount)
                
                class Developer(Employee):
                    raise_amount = 1.10
                    
                    def __init__(self, first, last, pay, prog_lang):
                        super().__init__(first, last, pay)
                        self.prog_lang = prog_lang
                
                
                class Manager(Employee):
                
                    def __init__(self, first, last, pay, employees=None):
                        super().__init__(first, last, pay)
                        if employees is None: 
                            self.employees = []
                        else: 
                            self.employees = employees
                
                    def add_emp(self, emp):
                        if emp not in self.employees:
                            self.employees.append(emp)
                
                    def remove_emp(self, emp):
                        if emp in self.employees:
                            self.employees.remove(emp)
                
                    def print_emps(self):
                        for emp in self.employees: 
                            print('-> {}'.format(emp.fullname()))
                
                
                dev_1 = Developer('Protick', 'Roy', 10000, 'Python')
                dev_2 = Developer('Test', 'User', 15000, 'JavaScript')
                mgr_1 = Manager('Sue', 'Smith', 90000, [dev_1])
                
                
                * inheritance allows us to inherit attributes and methods from a parent class 
                    we can create subclasses and get all the functionality of our parent class 
                    and then we can overwrite or add completely new functionality witout affecting 
                    the parent class in any way  
                
                * when python does not find a specific method in a subclass then it walks up the 
                    chain of inheritance until it finds what it is looking for this chain is called 
                    Method Resolution Order (MRO)

                * subclass also inherits parent's constructor method __init__()
                
                * every class in python inherits from the base builtins.object 

                * changing a class variable in subclass has no effect on the parent class 


            * Special / Magic / dunder methods 
                class Employee: 
                raise_amount = 1.04
                
                    def __init__(self, first, last, pay):
                        self.first = first
                        self.last = last
                        self.pay = pay
                        self.email = f'{first}.{last}@email.com'
                
                    def fullname(self)->str:
                        return f'{self.first} {self.last}'
                
                    def apply_raise(self):
                        self.pay = int(self.pay * self.raise_amount)
                
                    def __repr__(self):
                        return f'Employee({self.first}, {self.last}, {self.pay})'
                
                    def __str__(self):
                        return f'{self.fullname()} - {self.email}'
                
                    def __add__(self, other):
                        return self.pay + other.pay
                
                    def __len__(self):
                        return len(self.fullname())
                
                emp_1 = Employee('Protick', 'Roy', 10000)
                emp_2 = Employee('Test', 'User', 15000)
                
                print(emp_1 + emp_2)
                print(len(emp_1))
                
                * this methods emulates builtins behaviors in python 
                
                * __repr__() is called when we do repr(obj)
                    output of this method is meant to be used by developers to logging debugging 
                    from this method return a string that can be used to recreate that object on which it was called
                    you must implement this method even if you do not implement __str__()
                
                * __str__() is called when we do str(obj)
                    output of this method is meant to be used by the end user, readable representation of an object 
                
                * we can also implement operator overloading with special methods 
                    such as to overload the '+' operator's behavior for objects of a class we can 
                    define __add__() method in that class  
                    

            * Property getter, setter, deleter
                class Employee: 

                    def __init__(self, first, last):
                        self.first = first
                        self.last = last
                        # self.email = f'{first}.{last}@email.com'
                
                    # getter
                    @property
                    def fullname(self)->str:
                        return f'{self.first} {self.last}'
                
                    # setter
                    @fullname.setter
                    def fullname(self, name):
                        self.first, self.last = name.split(' ')
                        
                    # deleter 
                    @fullname.deleter 
                    def fullname(self):
                        print('Deleting fullname attribute!')
                        self.first = None 
                        self.last = None
                
                    @property
                    def email(self):
                        return f'{self.first}.{self.last}@email.com'
                
                
                emp_1 = Employee('John', 'Smith')
                emp_1.fullname = 'Protick Roy'
                
                print(emp_1.first)
                print(emp_1.email)
                print(emp_1.fullname)
                del emp_1.fullname
                print(emp_1.fullname)
                
                * property decorator allows us to define a method and access it like an attribute
                * private attribute by _ (it is by convention)
                * name mangling with __ (name is actually changed by python to _classattribute__variable_name)
        </p>

        <h2>Advanced Class</h2>
        <p>
            * understanding class instantiation
                '''
                    For new-style classes, implicit invocations of special methods are only guaranteed to work correctly if defined 
                    on an object's type(/ Class), not in the object's instance dictionary. 
                    That behavior is the reason why the following code raises an exception 
                    (unlike the equivalent example with old-style classes):
                    https://docs.python.org/dev/reference/datamodel.html#special-lookup
                '''
                * special methods are looked up and executed from a object's Class not from the object
                
                class Foo: 
                    def __init__(self):
                        pass
                
                bar = Foo()
                
                1. Foo is a class and classes in Python are objects too! Classes, functions, methods and instances
                    are all objects and whenever you put parentheses after their name you invoke their __call__() method
                
                2. as __call__() method is an instance method its first parameter is the object itself, __call__(self)
                
                3. special methods are looked up and executed from a object's Class not from the object itself
                    Foo() invokes __call__(), as Foo is also an object of class "type", type.__call__() is called
                
                4. so finally, 
                    Foo() => Foo.__call__(Foo, *args, **kwargs) => type.__call__(Foo, *args, **kwargs) 
                
                '''
                    # type.__call__(): 
                    
                    def __call__(obj_type, *args, **kwargs):
                        obj = obj_type.__new__(*args, **kwargs)
                        if obj is not None and issubclass(obj, obj_type):
                            obj.__init__(*args, **kwargs)
                        return obj
                    
                    # more like obj_type.__new__(obj_type, *args, **kwargs) ?
                '''
                5. for our example the call should look like, 
                    def __call__(Foo, *args, **kwargs):
                    
                    invokes, __new__() i.e., 
                    Foo.__new__(Foo, *args, **kwargs) => type.__new__(Foo, *args, **kwargs)
                            
                6. __new__():
                    a) Called to create a new instance of class, cls.__new__() is a static method 
                        (special-cased so you need not declare it as such)
                    
                    b) takes the class of which an instance was requested as its first argument. 
                    
                    c) The return value of __new__() should be the new object instance (usually an instance of cls).
                    
                7.  If __new__() is invoked during object construction and it returns an instance of cls, then 
                        the new instance's __init__() method will be invoked like __init__(self[, ...]), where self is the new instance 
                        and the remaining arguments are the same as were passed to the object constructor.
                
                    If __new__() does not return an instance of cls, then the new instance's __init__() method will not be invoked.
                
                8. If Foo class does implement a __new__() method in it then that will be called as like in type's __call__ method 
                    Foo.__new__() is not an implicit invocation, is it ?
                    but Foo() invocation of Foo.__call__() is 
                
                summary:
                1. Foo(*args, **kwargs) is equivalent to Foo.__call__(*args, **kwargs).
                2. Since Foo is an instance of type, Foo.__call__(*args, **kwargs) calls type.__call__(Foo, *args, **kwargs).
                3. type.__call__(Foo, *args, **kwargs) calls type.__new__(Foo, *args, **kwargs) which returns obj.
                4. obj is then initialized by calling obj.__init__(*args, **kwargs).
                5. obj is returned.



            * Old v/s new style class 

                1. In Python 2, to make a class a new-style class, it had to inherit from object 
                    (or from some superclass that did). Old-style classes do not inherit from object by default. 
                    Old-style instances are always implemented with a built-in 'instance' type.

                    Up to Python 2.1 the concept of class was unrelated to the concept of type, and old-style 
                    classes were the only flavor available. For an old-style class, the statement 
                    x.__class__ provides the class of x, but type(x) is always &lt;type 'instance'>. 
                    This reflects the fact that all old-style instances, independent of their class, are implemented 
                    with a single built-in type, called instance.

                2. A new-style class is a user-defined type, and is very similar to built-in types. New-style classes
                    in Python 3 implicitly inherit from object, so there is no need to specify MyClass(object).
                    
                    In Python 3, old-style classes were removed it only has new-style classes. No matter if you 
                    subclass from object or not, classes are new-style in Python 3. The inheritance of "object" 
                    is automatically assumed. 
                    [For the backward compatibility reason, it is not bad to keep "(object)" there though.]

                    A new-style class is simply a user-defined type, no more, no less. If x is an instance of 
                    a new-style class, then type(x) is typically the same as x.__class__ (although this is not 
                    guaranteed - a new-style class instance is permitted to override the value returned 
                    for x.__class__).

                3. The behavior of new-style classes differs from that of old-style classes in a number of
                    important details in addition to what type() returns. The reasoning was to remove the difference 
                    between built-in types and user-defined classes;
                    New-style classes were introduced in Python 2.2 to unify the concepts of class and type.

                
            * Benefits of new style class

                The major motivation for introducing new-style classes is to provide a unified object model with a 
                full meta-model. It also has a number of practical benefits, like the ability to subclass most 
                built-in types, or the introduction of “descriptors”, which enable computed properties.
                
                * Important behavior changes between old and new style classes
                
                    1. super added
                        the super() method to invoke methods from parent class 
                
                    2. MRO changed
                        Classic classes do a depth-first search from left to right. Stop on the first match. 
                        They do not have the __mro__ attribute. Old style classes use DLR or depth-first left 
                        to right algorithm whereas new style classes use C3 Linearization algorithm for method 
                        resolution while doing multiple inheritances.
                
                    3. descriptors added
                
                    4. new style class objects cannot be raised unless derived from Exception
                        
                    5. __slots__ added
                        Each python object has a __dict__ attribute which is a dictionary containing all other 
                        attributes. e.g. when you type self.attr python is actually doing self.__dict__['attr']. 
                        As you can imagine using a dictionary to store attribute takes some extra space & time 
                        for accessing it.
                
                        However, when you use __slots__, any object created for that class won't have a __dict__ 
                        attribute. Instead, all attribute access is done directly via pointers.

                        This way you can reduce the memory footprint of those classes 5-fold, 
                        at the expense of having to write custom pickle code, if and when that becomes necessary.
                        you can do python object serialization using the pickle module 
                
                        Also if you use __slots__ you can not dynamically add attributes to object after 
                        instantiation only pre-specified attributes in the __slot__ attributes can be added 

                        

            * 'type' v/s 'object' primitive type
                1. type in Python 3 is also an object - it inherits from object:
                        >>> isinstance(type, object)
                            True

                2. It means that type is an object, and it has inherited the behavior from the object class. 
                    That is what enables one to write things like
                        >>> type == type
                            True
                        >>> type.__eq__
                            &lt;slot wrapper '__eq__' of 'object' objects>

                3. The type.__eq__ was inherited from the object class.
                    But the object class itself is also a type:
                        >>> isinstance(object, type)
                            True

                4. It means that the class object as an object inherits the behaviour of type - type 
                    is object's metaclass. And of course type's metaclass is type:
                        >>> isinstance(type, type)
                            True

                5. And the class object is an object too:
                        >>> isinstance(object, object)
                            True 



            * Super and Method Resolution Order (MRO)
                * Method resolution order is resolved using C3 linearization algorithm.
                    This is specifically important to understand in case of inheritance where inheritance forms a 
                    diamond diagram. Inheritance is for code reuse. Using super() you can re-target from which 
                    parent class you want to access a method or property.
                    super() in python is different from super() of any other language. Generally in inheritance 
                    whenever you call super() is about calling your parents. 
                    
                    * In python, super() does call parents but not a class's parent rather the class's children's 
                        ancestor.

                    * super() just calls the next ancestor in line and the line is resolved by C3 linearization 
                        algorithm. Children gets called before their parents and parents gets called in the order 
                        listed.

                        Method resolution order
                            class Adam(object):
                                def print_me(self):
                                    print('class Adam')
                                
                            class Eve(object):
                                def print_me(self):
                                    print('class Eve')
                            
                            class Father(Adam, Eve):
                                def print_me(self):
                                    print('class Father')
                            
                            class Mother(Adam, Eve):
                                def print_me(self):
                                    print('class Mother')
                            
                            class Child(Father, Mother):
                                pass
                            
                            #  |  Method resolution order:
                            #  |      Child
                            #  |      Father
                            #  |      Mother
                            #  |      Adam
                            #  |      Eve
                            #  |      builtins.object


                    * you can use super to add dependency injection
                        subclass a parent class and in that subclass definition you add another parent class as 
                        ancestor. Then the instance of that subclass will look for method or property in the 
                        newly added ancestor class also. 

                        Dependency injection from R.H. presentation on super()
                            class Robot(object):
                                def left(self):
                                    print("walking left")
                                def right(self):
                                    print("walking right")
                        
                            class MyRobot(Robot):
                                def clean(self):
                                super().left()
                                super().right()
                            
                            # dependency 
                            class MockRobot(Robot):
                                def left(self):
                                    print("mock left")
                                def right(self):
                                    print("mock right")
                            
                            # injection 
                            class MyRobotTestable(MyRobot, MockRobot):
                                pass

                    * when you are using super for cooperative multiple inheritance use keyword arguments. 
                        and somebody at the end of the chain should not have super() in them.
                    * you do not need to use super with arguments as it was done in python 2.x like,
                        super(whose parent, where are we now)
                    * use help(ClassName or object) to retrieve the MRO

                                        
                    inheritance is a tool for code reuse 
                    1. in any class inside any method when you see super(), this super() will not return the proxy object of parent of that class 
                    rather it will return "the next parent's proxy object" according to the MRO of the subclass from where the look up originated

                    2. there is no function overloading in python and there is no function overriding if multiple functions override each 
                        other in the same scope. But you can definitely call parent class's method that you have overridden in the child class 
                        by using,
                            super(ChildClass, self).over_ridden_method()

                    * super() can also take two parameters: the first is the subclass, and the second parameter 
                        is an object that is an instance of that subclass.

                    * in python 2, we used to call super() like - Raymond Hettinger
                        super(Whose MRO, Where are we on that MRO)

                    * super() was introduced for multiple co-operative inheritance
                    * super() allows us to re-target the chosen parent class from which we will reuse some code

                    Note: Technically, super() doesn't return a method. It returns a proxy object. This is an object 
                    that delegates calls to the correct class methods without making an additional object in order to do so.
                    [a bit confused]


                    * cooperative multiple inheritance:
                        design a tree of classes where every class in the tree calls for the next in line 
                        1. meaning every class calls super() 
                        2. except for the last class in the tree create a stopper class 
                        3. create a cooperative wrapper class around a class that is not cooperative
                        4. use keyword arguments

                    * c3 linearization algorithm main points: 
                        1. children get called before their parents 
                        2. parents gets called in the order listed in the parent list specified in 
                            class Foo(parent1, parent2, parent3)
                            order of lookup according to C3: Foo > parent1 > parent2 > parent3


                    * you can also use composition, or mix-in class


                    
            * Python attributes access and descriptor protocol                 
                # Descriptor: 

                1. any Class that implements __get__(), __set__() or __delete__() method 
                    and descriptors can also have __set_name__() method defined in them 
            
                2. __set_name__() method of descriptor class is automatically called by the owner class which instantiates the descriptor.
                        When the owner class is being created, type.__new__() scans the class variables and makes callbacks to those 
                        with a __set_name__() hook.
                        This method, if present, is called even if the class is not a descriptor.
            
                        '''
                            class C: 
                                def __set_name__(self, ownerClass, classAttributeName)
                            
                            class A:
                                x = C()     # Automatically calls: x.__set_name__(A, 'x')
                        '''
            
                3. Descriptors only work when used as class variables. When put in instances, they have no effect.
                
                4. Descriptors get invoked by the dot operator during attribute lookup. If a descriptor is accessed indirectly 
                        with vars(some_class)[descriptor_name], the descriptor instance is returned without invoking it.
                
                5. Example: 
                    the class "Ten" is a descriptor because it implements the __get__() method of the descriptor protocol
                
                    # descriptor: Ten
                        class Ten: 
                            def __get__(self, obj, objtype=None):
                                print(self, obj, objtype)
                                return 10
                    
                    # Owner: here A is the owner class, which uses the descriptor "Ten" by using, y = Ten()
                        class A:
                            x = 5
                            y = Ten()
                        
                        objA = A() 
                        objA.y  invokes the descriptor "Ten"'s __get__() method
            
                6. Descriptor protocol methods and their signatures 
                    a) __get__(self, obj, objtype):
                    b) __set__(self, obj, value):
                    c) __delete__(self, obj):
                    d) __set_name__(self, objtype, name):
                
                    here, 
                    self    === the descriptor instance itself, 
                    obj     === the instance of the owner class on which the attribute is being looked up,
                    objtype === the owner class itself, which instantiates the descriptor and bind that to a class variable
                    name    === the class variable name which will be assigned with the descriptor instance
                
                7. The main motivation for descriptors is to provide a hook allowing objects stored in class variables to 
                        control what happens during attribute lookup.
            
                8. NOTE: Python descriptors are instantiated just once per class. That means that every single instance 
                        of a class containing a descriptor shares that descriptor instance. 
            
                9. Simple example of a descriptor: 
                    import logging
                    logging.basicConfig(level=logging.INFO)
                
                    class LoggedAccess: 
                        def __set_name__(self, owner, name):
                            self.public_name = name
                            self.private_name = f"_{name}"
                
                        def __get__(self, obj, objtype=None):
                            value = getattr(obj, self.private_name)
                            logging.info(f"Accessing {self.public_name} giving {value}")
                            return value 
                    
                        def __set__(self, obj, value):
                            logging.info(f"Updating {self.public_name} to {value}")
                            setattr(obj, self.private_name, value)
                
                    class Person: 
                        age = LoggedAccess()
                        name = LoggedAccess()
                
                        def __init__(self, name, age) -> None:
                            self.name = name 
                            self.age = age      invoking descriptor's get

                    Roma = Person("Roma sen", 21)
                    print(Roma.name)
                    print(Roma.age)

                10. descriptor invocation rules,
                    # Descriptors are invoked by the __getattribute__() method.

                    # Classes inherit this machinery from object, type, or super().
                    
                    # Overriding __getattribute__() prevents automatic descriptor calls because all the descriptor 
                        logic is in that method.
                    
                    # object.__getattribute__() and type.__getattribute__() make different calls to __get__(). 
                        first includes the instance and may include the class. The second puts in None for the instance 
                        and always includes the class.
                    
                    # Data descriptors always override instance dictionaries.
                    
                    # Non-data descriptors may be overridden by instance dictionaries.

                    # descriptor that implements either or both of __set__() or __delete__() methods is called data descriptor.

            
                * Metaclass 
                    * all objects in python have a "__class__" attribute which stores from what class the object is created 

                    1. 
                        x = 1                   # equivalent to x = int(1)
                        print(x, x.__class__)   # 1 &lt;class 'int'&gt;

                        y = 1.5                 # equivalent to x = float(1.5)
                        print(y, y.__class__)   # 1.5 &lt;class 'float'&gt;

                        z = "this is a string"  # equivalent to z = str("this is a string")
                        print(z, z.__class__)   # this is a string &lt;class 'str'&gt;

                    2. A class is capable of creating objects (called instances) and the class itself is also an object
                        that is why you can 
                            a. assign the class to other variable 
                            b. add attributes to the "Class that is also an object"
                            c. pass the "class object" to other functions as parameter 
                            d. also, assigning a "class object" to other variable will not change the 
                                "class object's" __name__ attribute


                    3. now lets see what is the "__class__" of a class ?
                        class Foo:              # equivalent to Foo = type("Foo", (), {})
                            pass 
                        print(Foo.__class__)    # &lt;class 'type'&gt;

                    4.  so "class Foo" is an object of class "type" and that is why we call "type" a metaclass 
                        So, a metaclass is just the stuff that creates class objects.
                        You can call it a 'class factory' if you wish.

                    5. when we want to create an object from a class we use "ClassName()" that invokes the 
                        object's obj.__call__(obj, *arguments, **args) method and special methods are  always 
                        looked up on object's parent class and it returns an object of type "ClassName"

                    6. similarly, a class-object is created by the 'type' metaclass by invoking type() with arguments
                        type("class Name", (classes it inherits in a tuple), {class attributes in a dictionary})
                        
                        *** Everything is an object in Python, and they are all either instance of classes or 
                            instances of metaclasses. Except for type.
                            "type" is actually its own metaclass. This is not something you could reproduce in pure Python, 
                            and is done by cheating a little bit at the implementation level.

                    7. lets create class "Foo" using type() constructor of "type class"
                        '''
                        Example 1: class that inherits other class and has methods
                            class Foo: 
                                bar = True

                            class MyClass(Foo):

                                def echo_bar(self):
                                    print(f"bar: {self.bar}")

                            # is same as,

                            def echo_bar(self):
                                print(f"bar: {self.bar}")

                            Foo = type('Foo', (), {"bar": True})
                            MyClass = type('MyClass', (Foo, ), {"echo_bar": echo_bar})

                            regular_cls_obj = MyClass()
                            regular_cls_obj.echo_bar()
                        '''

                    8. type is the built-in metaclass Python uses, but of course, you can create your own metaclass.

                        in python 2, you can add a "__metaclass__" attribute to your class definition, 
                        like, 
                            '''
                                # The "__metaclass__" attribute 
                                class Foo(object):
                                    __metaclass__ = "Your choses meta class"
                            '''

                        if you do so, python will use the specified metaclass to create the class "Foo"
                        You write class Foo(object) first, but the class object Foo is not created in memory yet.
                        Python will look for __metaclass__ attribute in the class definition. If it finds it, it will use it 
                        to create the "class object" Foo. 
                        If it doesn't,  it will look for a __metaclass__ at the MODULE level, and try to do the same 
                        Then if it can't find any __metaclass__ at all, it will use the the first parent's own metaclass
                        
                        If parent class used a __metaclass__ attribute that created parent class with type() (and not type.__new__()), 
                        the subclasses will not inherit that behavior.

                        the parent Class's __metaclass__ attribute is not inherited by the child class but the metaclass of the parent class 
                        will be inherited i.e., child subclass inherits parent class's metaclass by parent.__class__



                        PYTHON 3 
                        the __metaclass__ attribute is no longer used, in favor of a keyword argument in the list of base classes.
                        One thing added to metaclasses in Python 3 is that you can also pass attributes as keyword-arguments into a metaclass,
                        class Foo(object, metaclass=something, kwarg1=value1, kwarg2=value2)
                        
                        and in Python 3 if you do this call with keyword arguments, like this:
                        class Foo(object, metaclass=MyMetaclass, kwarg1=value1):
                        It translates to this in the metaclass to use it:
                        class MyMetaclass(type):
                            def __new__(cls, clsname, bases, dct, kwargs1=default):


                    9. Now the big question is, what can you put in __metaclass__ or metaclass=?
                        The answer is something that can create a class.
                        And what can create a class? type, or anything that subclasses or uses it.

                    10. __metaclass__ can actually be any callable, it doesn't need to be a formal class
                        the callable should ultimately call the type() constructor to create the class-object 

                        Example 1: using a function as __metaclass__ value in the global scope

                            def upper_attr(future_class_name, future_class_inherits, future_class_dict):
                                uppercase_attrs = {attr if attr.startswith("__") else attr.upper(): v for attr, v in future_class_dict.items()}
                                
                                # let type() do the class creation 
                                return type(future_class_name, future_class_inherits, uppercase_attrs)

                            class Foo(metaclass=upper_attr):
                                bar = 'bip'

                            baz = Foo()

                            print(Foo.__class__)
                            print(baz.__class__)
                            print(isinstance(baz, Foo))
                            print(baz.BAR)

                    11. now class body of Foo will be scanned for __metaclass__ attribute, then it will be looked for 
                        in class parent list section we defined "metaclass" attribute and set its value to "upper_attr" function 
                        which is a callable 
                        
                        now python will use upper_attr function to create a new "class object" name Foo
                        so it will be called as,
                        upper_attr('Foo', (), {"bar": 'bip'})


                    12. a class as a metaclass value
                        Example 2: Example 1 rewrite using an actual metaclass 
                            class UpperAttrMetaClass(type):
                                def __new__(upperattr_metaclass, future_class_name, future_class_inherits, future_class_dict):
                                    uppercase_attrs = {attr if attr.startswith("__") else attr.upper(): v for attr, v in future_class_dict.items()} 
                                    return type(future_class_name, future_class_inherits, uppercase_attrs)


                        # now lets rewrite this example using short variable names 
                            class UpperAttrMetaClass(type):
                                def __new__(cls, clsname, bases, attrs):
                                    # here __new__ takes an additional first argument "cls", __new__ always receives 
                                    # the class it's defined in, as the first parameter

                                    uppercase_attrs = {attr if attr.startswith("__") else attr.upper(): v for attr, v in attrs.items()} 
                                    return type(clsname, bases, uppercase_attrs)


                        class Foo(metaclass=UpperAttrMetaClass):
                            bar = "bip"

                    13. now lets rewrite this example by calling the __new__() function on type meta class instead 
                        of calling type() directly 
                        class UpperAttrMetaClass(type):
                            def __new__(cls, clsname, bases, attrs):
                                uppercase_attrs = {attr if attr.startswith("__") else attr.upper(): v for attr, v in attrs.items()} 
                                return type.__new__(cls, clsname, bases, uppercase_attrs)

                            # return type.__new__(cls, clsname, bases, uppercase_attrs) this call to __new__() 
                            # of parent meta class "type"
                            
                            # appropriately sets Foo's __class__ to "UpperAttrMetaClass" as it should


                        # now lets rewrite this example by calling the __new__() function of type meta class using super() 
                            class UpperAttrMetaClass(type):
                                def __new__(cls, clsname, bases, attrs):
                                    uppercase_attrs = {attr if attr.startswith("__") else attr.upper(): v for attr, v in attrs.items()} 
                                    return super().__new__(cls, clsname, bases, uppercase_attrs)

                            class Foo(metaclass=UpperAttrMetaClass):
                                bar = "bip"

                            baz = Foo()
                            print(Foo.__class__.__class__) &lt;class 'type'&gt;
                            print(Foo.__class__)           &lt;class '__main__.UpperAttrMetaClass'&gt; 
                            print(baz.__class__)           &lt;class '__main__.Foo'&gt;
                            print(baz.BAR)                 bip


                    14. so what does a metaclass do ?
                        a. intercept a class creation
                        b. modify the class
                        c. return the modified class

                    15. Purpose of a metaclass 
                        a. The main purpose of a metaclass is to change the class automatically, when it's created.
                        b. You usually do this for APIs, where you want to create classes matching the current context.
        </p>



        <h2> First class function, Closure, Decorator, Generator, Iterator</h2>
        <p>
            * First Class Function 
                A programming language said to have first class function if treats functions as first-class citizens 

            * first-class citizen 
                A first class citizen (sometimes called first-class objects) in a programming language is an 
                entity which supports all the operations generally available to other entities. 
                These operations typically include being passed as an argument, returned from a function 
                and assigned to a variable. 
                if functions are treated as values
            
            * higher order function 
                if a function takes another function as argument or return a function then it is called a 
                higher order function, map() is a higher order function because it takes a callback function 
                as an argument.

                Example 1: first class function
                            def square(x):
                                return x * x 
                    
                            f = square
                            print(square)
                            print(f(5))
                

                Example 2.1: higher order function
                            def square(num):
                                return num * num
                    
                            def cube(num):
                                    return num * num * num
                        
                            # map_to() is a higher order function as it takes mapper function's as an argument
                            def map_to(mapper, nums):
                                res = []
                                for num in nums:
                                    res.append(mapper(num))
                    
                                return res
                
                            nums = [1, 2, 3, 4]
                            res = map_to(cube, nums)
                            print(res)


                Example 2.2: Higher order function 
                            def log_message(msg):
                                def print_log():
                                    print("Log: ", msg)

                                # log_message() is a higher order function because it returns print_log() function
                                return print_log

                            log = log_message("This message need to be logged !")
                            log()



            * Closure 
                In simple terms, a closure is an inner function that remember and has access to variables in 
                the local scope in which it was created, even after the outer function has finished executing

                * Example 1: 
                            def outer_func():
                                message = 'hi'
                                def inner_func():
                                        print(message)
                                return inner_func

                            func = outer_func()
                            func() # func == inner_func

                Example 2: 
                            def tag(t):
                                def content(c):
                                    return f'&lt;{t}>{c}&lt;/{t}>'
                                return content

                            h1 = tag('h1')
                            h1_element = h1('This is heading level 1')
                            print(h1_element) # &lt;h1>This is heading level 1&lt;/h1>
                
                
                Example 3: 
                # takes a function and inject logging functionality in it 

                            import logging 
                            logging.basicConfig(filename="example.log", level=logging.INFO)
                            
                            def logger(func):
                                def log_func(*args):
                                    logging.info(f'Running: {func.__name__} with arguments: {args}')
                                    print(func(*args))
                                return log_func
                                
                            def add(x, y):
                                return x + y
                            
                            def multiply(x, y):
                                return x * y
                            
                            log_add = logger(add)
                            log_mul = logger(multiply)
                            
                            log_add(10, 20)
                            log_mul(10, 20)
            
            
            * Decorator 
                a decorator is a function that takes another function as an argument, adds some kind of 
                functionality and then returns another function without altering the source code of original 
                function that we passed in to the decorator 

                    def decorator_function(original_function):
                        def wrapper_function():
                            print(f'wrapper function ran before executing {original_function.__name__}')
                            return original_function()
                        return wrapper_function
                    
                    def display():
                        print('display function ran')
                    
                    display = decorator_function(display)
                    display()
            

                * in python we can achieve the same as the previous code example by, 

                    def decorator_function(original_function):
                        def wrapper_function():
                            print(f'wrapper function ran before executing {original_function.__name__}')
                            return original_function()
                        return wrapper_function
                    
                    @decorator_function
                    def display():
                        print('display function ran')
                    
                    @decorator_function
                    def display_info(name, age):
                        print(f'display info ran with arguments {name, age}')
                    
                    display()
                    display_info('John', 25)
                

                * so @decorator keyword replaces original function with wrapper function and takes original 
                    function as its first argument automatically 

                * so now, to pass argument to the wrapper function we need to define wrapper function with 
                    parameters that can recieve multiple positional and keyword arguments we can do so by, 

                        def decorator_function(original_function):
                            def wrapper_function(*args, **kwargs):
                                print(f'wrapper function ran before executing {original_function.__name__}')
                                return original_function(*args, **kwargs)
                        
                            return wrapper_function
                        
                        @decorator_function
                        def display():
                            print('display function ran')
                        
                        @decorator_function
                        def display_info(name, age):
                            print(f'display info ran with arguments {name, age}')
                        
                        display()
                        display_info('John', 25)
                        
            
            * python classes as decorators 
                class decorator_class(object):
                    def __init__(self, original_function):
                        self.original_function = original_function
                
                    def __call__(self, *args, **kwds):
                        print(f'call method executed before executing {self.original_function.__name__}')
                        return self.original_function(*args, **kwds)
                
                
                @decorator_class
                def display():
                    print('display function ran')
                
                @decorator_class
                def display_info(name, age):
                    print(f'display info ran with arguments {name, age}')
                
                display()
                display_info('John', 25)
            
            
            * practical application of decorators 
                from functools import wraps
                def logger(orig_func):
                    import logging
                    logging.basicConfig(filename=f'{orig_func.__name__}.log', level=logging.INFO)
                
                    @wraps(orig_func)
                    def wrapper(*args, **kwargs):
                        logging.info('ran with arguments {} and keword arguments {}'.format(args, kwargs))
                        return orig_func(*args, **kwargs)
                    return wrapper
                
                def timer(orig_func):
                    import time
                
                    @wraps(orig_func)
                    def wrapper(*args, **kwargs):
                        t1 = time.time()
                        result = orig_func(*args, **kwargs)
                        execution_time = time.time() - t1
                        print(f'{orig_func.__name__} ran in {execution_time} seconds')
                        return result
                    return wrapper
                
                @timer
                @logger
                def display():
                    print('display function ran')
                
                @timer
                @logger
                def display_info(name, age):
                    print(f'display info ran with arguments {name, age}')
                
                display()
                display_info('John', 25)

                # 1. functool's wraps is a decorator that takes the original function as an argument and 
                        changes the returned wrapper function's name to the original function's name 
                # 2. in case of stacked decorators like in the previous example @timer and @logger were 
                        stacked on top of each other. The decorator that is closest to the original function 
                        is executed first.
            
            
            * decorators that take arguments 
                write another function and recieve arguments and define the decorator function as an inner function.
                Recive and use the arguments in the inner functions and return the decorator function from it.

                def prefix_decorator(prefix): # like this function 
                    def decorator_function(original_function):
                        def wrapper_function(*args, **kwargs):
                            print(f'{prefix}: {original_function.__name__}')
                            return original_function(*args, **kwargs)
                        return wrapper_function
                    return decorator_function
                
                @prefix_decorator('TESTING: ') # received arguments 
                def display_info(name, age):
                    print(f'display info ran with arguments {name, age}')
                
                display_info('John', 25)
                
                
            * Generator
                generator functions are a special kind of function that return a lazy iterator. 
                These are objects that you can loop over like a list. However, unlike lists, lazy iterators 
                do not store their contents in memory

                generators do not hold the entire result in memory it yields one result at a time 
                it waits for us to ask for the next result
 
                    def square_nums(nums):
                        result = []
                        for i in nums:
                            result.append(i * i) 
                        return result

                    nums = [1, 2, 3, 4]
                    snums = square_nums(nums)

                    * to transform the previous example to generator 
                        def square_nums(nums):
                            for i in nums:
                                yield(i * i) 

                        nums = [1, 2, 3, 4]
                        snums = square_nums(nums)

                    * to ask for the next result we have to use, 
                        next(generator object) 

                        next(snums) == 1
                        next(snums) == 4
                        next(snums) == 9
                        next(snums) == 16
                        next(snums) == StopIteration exception 
                        thrown as we reach the end of a generator; i.e., generator is exhausted

                    * 'yield' returns a generator object

                * Iterate a generator using 'for' loop
                    for i in snums: 
                        print(i)
                    * for loop knows when to stop iteration or when generator is exhausted 
                    
                    * we can also rewrite the previous code example with while loop in that case we have to 
                        manually handle the StopIteration exceptin like so, 
                        while True: 
                            try:
                                print(next(snums))
                            except StopIteration as e: 
                                break
                
                * Generator expression 
                    * list comprehension 
                        sqr_nums = [ n*n for n in nums]

                    * generator expression 
                        gen_sqr_nums = (n*n for n in nums)
                        
                        * 'gen_sqr_nums' holds a generator object on which we have to call next() to iterate 
                            through it. or we can convert the generator object to a list which will diminish the
                            advantage of using a generator over a list
                            li = list(gen_sqr_nums)
                            
                        * generator expression returns a generator object

                * Advantage of using a generator over a list 
                    1. List stores all the values of a sequence in a list which consumes memory space 
                    2. Generator does not store all the values in memory it remembers the current state and 
                        computes the next value as we call next() on it. 
                    3. In list comprehension it computes and stores all the computed values in a list 
                        which takes more time compared to generator expression as it just returns a generator 
                        object which computes the value when asked to.


            * Iterator 
                an iterator is an object with a state so that it remembers where it is during iteration and 
                iterator also know how to get their next value. 
                They get their next value with a __next__() method 
            
                * iterables 
                    an iterable means it is something that can be looped over 
                    for example a book with multiple pages can be considered as an iterable as we can turn 
                    the pages to traverse through all the pages

                * iterable vs iterator example 
                    * A list is iterable but not an iterator 
                        nums = [1, 2, 3, 4]
                
                    * you can also iterate through sets, tuples, dictionaries, generators, files etc,
                        how to determine if something is iterable ?
                            to something to be an iterable it needs to have a method implemented in it 
                            called __iter__()
                            print(dir(nums))    __iter__ is listed in the result so it is an iterable

                            * __iter__() returns an iterator which for loop uses to iterate through the list 
                                but list does not have a __next__() method so it is not an iterator 
                        
                                print(next(nums))
                                TypeEroor: 'list' object is not an iterator

                * when we run next() on an object it executes the __next__() defined on that object 
                * when we run iter() on an object it executes the __iter__() defined on that object
                * iterator is also an iterable but iterable is not always an iterator object 
                * a generator is also an iterator but an iterator does not have to be a generator
                            
            * iterator throws a StopIteration exception when the iterator is exhausted. 
            * you can only go forward in an iterator, there is not resetting it, going back to previous entry 
                or copying an iterator


            * mimic the range() iterator 
                class MyRange:
                    def __init__(self, start, end):
                        self.value = start
                        self.end = end

                    def __iter__(self):
                        return self

                    def __next__(self):
                        if(self.value >= self.end):
                            raise StopIteration
                        current = self.value
                        self.value += 1
                        return current

            * mimic the range() iterator with a generator 
                def my_range(start, end):
                    while start &lt; end:
                        yield start 
                        start += 1
                    # generator raises StopIteration exception automatically 


                nums = MyRange(0, 10)
                g_nums = my_range(0, 10)

                for num in g_nums: 
                    print(num)

            * iterator can go on indefinitely it does not have to have a end value or stopping condition
            * You may want to use a custom iterator, rather than a generator, when you need a class with 
                somewhat complex state-maintaining behavior, or want to expose other methods besides __next__ 
                (and __iter__ and __init__). 
            * Generators provide an easy, built-in way to create instances of Iterators. Generator function 
                is still a function and when called, returns an instance of a generator object

            * Think of a generator as a resumable function.
                yield behaves like return in the sense that values that are yielded get "returned" by the generator. 
                Unlike return, however, the next time the generator gets asked for a value, the generator's function, 
                resumes where it left off -- after the last yield statement -- and continues to run until it hits 
                another yield statement.
                Behind the scenes, when you call the generator function the generator object is defined and returned 
                for you to have a next attribute.

                When you call a function that contains a yield statement anywhere, you get a generator object, 
                but no code runs. Then each time you extract an object from the generator, Python executes code 
                in the function until it comes to a yield statement, then pauses and delivers the object. 
                When you extract another object, Python resumes just after the yield and continues until it 
                reaches another yield (often the same one, but one iteration later). This continues until the 
                function runs off the end, at which point the generator is deemed exhausted.
        </p>

        <h2>Modules and standard library</h2>
        <p>
            Module 
                Python has a way to put definitions in a file and use them in a script or in an interactive
                instance of the interpreter. Such a file is called a module; definitions from a module can 
                be imported into other modules or into the main module
                A module is a file containing Python definitions and statements. The file name is the 
                module name with the suffix .py appended

                * Python searches for modules in the path list defined in sys.path
                * Currently executing file's path is also automatically added to the sys.path list. 

                * how to import a module 
                    all statements defined in a module are executed before it is actually imported into antoher module or scripts

                    1. import my_module 
                        you can use variable or functions defined in a module by 
                            module_name.variable 
                            module_name.function()

                    2. import my_module as mm 
                        'my_module' will be imported with the name 'mm'
                        mm.varible 
                        mm.function()

                    3. from my_module import variable, function 
                        only selected variable and function will be imported into a module other than the 
                        whole module 

                    4. from my_module import variable as var, function as func 
                        selected imports will be named as given while being imported 

                    5. from my_module import * 
                        imports everything from a module 
                        Not recommended as it convolutes the global namespace
        </p>

        <h2>Devlopment tools, package installer and Virtual environments</h2>
        <p>

            * Package installer for python - PIP 
                we can use this package manager tool to install, uninstall, upgrade packages/modules
                
                1. pip search package-name 
                    searches for a package with the given package-name and returns package list 

                2. pip list 
                    lists out packages installed for current environment 
                
                3. pip install package-name 
                    installs package named 'package-name' into the current environment 
                    
                4. pip install package-name=version 
                    install package with specified version 

                5. pip list --outdated (or -O)
                    lists out outdated packages installed in the current environment 

                6. pip install --upgrade (or -U) package-name 
                    upgrades a package to the latest version 
                    
                7. pip freeze > requirements.txt 
                    lists out currently installed packages in the active environment to requirements.txt file 

                8. pip instlal -r requirements.txt 
                    install all packages listed in the requirements.txt file to the currently active environment. 


            * virtual envirnments 
                python execution environment with chosen python interpreter and modules 
                there are many tools available to create a virtual environment such as venv, 
                virtualenv, pyenv, anaconda etc. 

                * virtualenv 
                    1. pip instlal virtualenv 

                    2. virtualenv virtaul-environment 
                        will create a virtual environment named 'virtaul-environment' with the system default 
                        python interpretor set as default interpreter for the newly created virtual environment 

                    3. virtualenv -p path/to/python/interpreter/executable virtual-environment 
                        will create a virtual environment which has its interpreter set to the specified interpreter
                    
                    4. Activate a virtual environment 
                        source virtual-environment-directory/bin/activate 

                    5. deactivate 
                        deactivates the currently active virtual environment 
                    
        </p>

        <h2>PEP 8 Coding styles</h2>
        <p>
            1. Use 4-space indentation, and no tabs.
            2. 4 spaces are a good compromise between small indentation (allows greater nesting depth) 
                and large indentation (easier to read). Tabs introduce confusion, and are best left out.
            3. Wrap lines so that they don't exceed 79 characters.
            4. Use blank lines to separate functions and classes, and larger blocks of code inside functions.
            5. When possible, put comments on a line of their own.
            6. Use docstrings.
            7. Use spaces around operators and after commas, but not directly inside bracketing 
                constructs: a = f(1, 2) + g(3, 4).
            8. Name your classes and functions consistently; the convention is to use UpperCamelCase for classes and 
                lowercase_with_underscores for functions and methods. Always use self as the name for the first method 
                argument (see A First Look at Classes for more on classes and methods).
            9. Don't use fancy encodings if your code is meant to be used in international environments. 
                Python's default, UTF-8, or even plain ASCII work best in any case.
            10. Likewise, don't use non-ASCII characters in identifiers if there is only the slightest chance people 
                speaking a different language will read or maintain the code.
        </p>
        </pre>
    </main>
</body>